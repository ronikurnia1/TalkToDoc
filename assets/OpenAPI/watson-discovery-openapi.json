{
  "openapi": "3.0.0",
  "info": {
    "title": "Discovery v2",
    "version": "2.0",
    "description": "IBM Watson&reg; Discovery is a cognitive search and content analytics engine that you can add to applications to identify patterns, trends and actionable insights to drive better decision-making. Securely unify structured and unstructured data with pre-enriched content, and use a simplified query language to eliminate the need for manual filtering of results.",
    "x-version-date": "2023-03-31",
    "x-vcap-service-name": "discovery",
    "x-alternate-name": "Discovery",
    "x-sdk-supported-languages": [
      "java",
      "node",
      "python",
      "dotnet-standard"
    ],
    "x-codegen-config": {
      "includeExternalConfig": true,
      "supportNodeCallbacks": true,
      "dotnet-standard": {
        "apiPackage": "IBM.Watson"
      },
      "go": {
        "apiPackage": "github.com/watson-developer-cloud/go-sdk/v2"
      },
      "cli": {
        "apiPackage": "cli-watson-plugin",
        "cliPluginName": "watson",
        "serviceCommandName": "discovery-v2"
      },
      "java": {
        "apiPackage": "com.ibm.watson"
      },
      "python": {
        "apiPackage": "ibm_watson"
      },
      "swift": {
        "resterror-alias": "WatsonError",
        "restresponse-alias": "WatsonResponse"
      }
    },
    "x-last-updated": "2023-06-23"
  },
  "security": [
    {
      "IAM": []
    }
  ],
  "externalDocs": {
    "description": "For more information about this service, see docs.",
    "url": "https://cloud.ibm.com/docs/discovery-data",
    "x-release-notes": "https://cloud.ibm.com/docs/discovery-data?topic=discovery-data-release-notes"
  },
  "x-doc-properties": [
    "hasCustomEndpoints",
    "hasRelatedApis",
    "mergedDefinition"
  ],
  "tags": [
    {
      "name": "Projects",
      "description": "List the projects in your service instance. Get, create, update, or delete a project."
    },
    {
      "name": "Collections",
      "description": "List the collections in a project. Get, create, update, or delete a collection."
    },
    {
      "name": "Documents",
      "description": "List the documents in a collection. Get, add, update, or delete a document."
    },
    {
      "name": "Queries",
      "description": "Query the documents in your project."
    },
    {
      "name": "Query modifications",
      "description": "Apply customizations, such as custom synonyms and stop words, to queries that are submitted for the collection."
    },
    {
      "name": "Component settings",
      "description": "Retrieve the default configuration settings for components."
    },
    {
      "name": "Training data",
      "description": "Manage training queries for a project."
    },
    {
      "name": "Enrichments",
      "description": "List the enrichments in your project. Get, create, update, or delete an enrichment."
    },
    {
      "name": "Batches",
      "description": "List the batches in your project. Pull batches from Discovery and push batches to Discovery"
    },
    {
      "name": "Document classifiers",
      "description": "List the document classifiers in your project. Get, create, update, or delete a document classifier."
    },
    {
      "name": "Document classifier models",
      "description": "List the document classifier models in your project. Get, create, update, or delete a document classifier model."
    },
    {
      "name": "Analyze",
      "description": "Process text documents through the enrichment pipeline of the Discovery service without storing the source documents."
    },
    {
      "name": "User data",
      "description": "Delete data that is associated with a specified customer ID."
    }
  ],
  "paths": {
    "/v2/projects/{project_id}/collections": {
      "get": {
        "operationId": "listCollections",
        "summary": "List collections",
        "description": "Lists existing collections for the specified project.",
        "tags": [
          "Collections"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/versionParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCollectionsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.ListCollections(\n",
                      "    projectId: \"{project_id}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "ListCollectionsOptions options = new ListCollectionsOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .build();\n",
                      "\n",
                      "ListCollectionsResponse response = discovery.listCollections(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "};\n",
                      "\n",
                      "discovery.listCollections(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.list_collections(\n",
                      "  project_id='{project_id}'\n",
                      ").get_result()\n",
                      "\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "createCollection",
        "summary": "Create a collection",
        "description": "Create a new collection in the specified project.",
        "tags": [
          "Collections"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/CreateCollection"
        },
        "responses": {
          "201": {
            "description": "The collection has been successfully created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionDetails"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Tutorials",
                      "collection_id": "eb0215ed-6ec2-132a-0000-017b740f39c1",
                      "description": "Instructional PDFs",
                      "created": "2021-08-23T17:29:21.104Z",
                      "language": "en",
                      "enrichments": [
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000002",
                          "fields": [
                            "text"
                          ]
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-00000000001e",
                          "fields": [
                            "text"
                          ]
                        }
                      ],
                      "smart_document_understanding": {
                        "enabled": false
                      },
                      "source_document_counts": {
                        "pending": 0,
                        "processing": 0,
                        "available": 0,
                        "failed": 0
                      },
                      "document_counts": {
                        "processing": 0,
                        "available": 0,
                        "failed": 0
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.\n\n- No request body.\n\n- Missing rquired request parameter or its value.\n\n- Missing project.\n\n- Too many collections in project.\n\n- Too many total collections.\n\n- Unsupported language is requested.\n\n- Invalid normalization operation is requested.\n\n- Missing normalization source.\n\n- Missing normalization destination.\n\n- Invalid normalization destination.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\"name\\\": \\\"Tutorials\\\", \\\n",
                      "  \\\"description\\\": \\\"Instructional PDFs\\\" }\" \\\n",
                      "\"{url}/v2/projects/{project_id}/collections?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/query": {
      "post": {
        "operationId": "query",
        "summary": "Query a project",
        "description": "Search your data by submitting queries that are written in natural language or formatted in the Discovery Query Language. For more information, see the [Discovery documentation](/docs/discovery-data?topic=discovery-data-query-concepts). The default query parameters differ by project type. For more information about the project default settings, see the [Discovery documentation](/docs/discovery-data?topic=discovery-data-query-defaults). See [the Projects API documentation](#create-project) for details about how to set custom default query settings. \n\nThe length of the UTF-8 encoding of the POST body cannot exceed 10,000 bytes, which is roughly equivalent to 10,000 characters in English.",
        "tags": [
          "Queries"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/versionParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/QueryLarge"
        },
        "x-codegen-request-body-name": "query_long",
        "responses": {
          "200": {
            "description": "Query executed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request.\n\n* Project has no collections.\n\n* A list of document ids is required in **similar.document_ids** when **similar.enabled** is `true`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"collection_ids\\\": [  \\\n",
                      "    \\\"{collection_id_1}\\\", \\\n",
                      "    \\\"{collection_id_2}\\\" \\\n",
                      "  ], \\\n",
                      "  \\\"query\\\": \\\"text:IBM\\\" \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/query?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.Query(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    query: \"{field}:{value}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "QueryOptions options = new QueryOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .query(\"{field}:{value}\")\n",
                      "  .build();\n",
                      "\n",
                      "QueryResponse response = discovery.query(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  query: '{field}:{value}',\n",
                      "};\n",
                      "\n",
                      "discovery.query(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.query(\n",
                      "  project_id='{project_id}',\n",
                      "  query='{field:value}'\n",
                      ").get_result()\n",
                      "\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/autocompletion": {
      "get": {
        "operationId": "getAutocompletion",
        "summary": "Get Autocomplete Suggestions",
        "description": "Returns completion query suggestions for the specified prefix.\n\nSuggested words are based on terms from the project documents. Suggestions are not based on terms from the project's search history, and the project does not learn from previous user choices.",
        "tags": [
          "Queries"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdsParam"
          },
          {
            "$ref": "#/components/parameters/acFieldParam"
          },
          {
            "$ref": "#/components/parameters/acPrefixParam"
          },
          {
            "$ref": "#/components/parameters/acCountParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Object that contains an array of possible completions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Completions"
                },
                "examples": {
                  "response": {
                    "value": {
                      "completions": [
                        "absolutely"
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "The specified field does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/autocompletion?collection_ids={collection_id_1},{collection_id_2}&prefix=ab&version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.GetAutocompletion(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    prefix: \"Ho\",\n",
                      "    count: 5\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "GetAutocompletionOptions options = new GetAutocompletionOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .prefix(\"Ho\")\n",
                      "  .count(5L)\n",
                      "  .build();\n",
                      "\n",
                      "Completions response = discovery.getAutocompletion(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  prefix: 'Ho',\n",
                      "  count: 5,\n",
                      "};\n",
                      "\n",
                      "discovery.getAutocompletion(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.get_autocompletion(\n",
                      "  project_id='{project_id}',\n",
                      "  prefix='Ho',\n",
                      "  count=5\n",
                      ").get_result()\n",
                      "\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/component_settings": {
      "get": {
        "operationId": "getComponentSettings",
        "summary": "List component settings",
        "description": "Returns default configuration settings for components.",
        "tags": [
          "Component settings"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/versionParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComponentSettingsResponse"
                },
                "examples": {
                  "response": {
                    "value": {
                      "results_per_page": 5,
                      "structured_search": false,
                      "fields_shown": {
                        "body": {
                          "use_passage": true,
                          "field": ""
                        },
                        "title": {
                          "field": "title"
                        }
                      },
                      "aggregations": [
                        {
                          "name": "entities",
                          "label": "Top Entities",
                          "multiple_selections_allowed": true
                        },
                        {
                          "name": "_system_collections",
                          "label": "Collections",
                          "multiple_selections_allowed": true
                        }
                      ],
                      "autocomplete": true
                    }
                  }
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/component_settings?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.GetComponentSettings(\n",
                      "    projectId: \"{project_id}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "GetComponentSettingsOptions options = new GetComponentSettingsOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .build();\n",
                      "\n",
                      "ComponentSettingsResponse response = discovery.getComponentSettings(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const fs = require('fs');\n",
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "};\n",
                      "\n",
                      "discovery.getComponentSettings(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.get_component_settings(\n",
                      "  project_id='{project_id}'\n",
                      ").get_result()\n",
                      "\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}/documents": {
      "get": {
        "operationId": "listDocuments",
        "summary": "List documents",
        "description": "Lists the documents in the specified collection. The list includes only the document ID of each document and returns information for up to 10,000 documents.\n\n**Note**: This method is available only from Cloud Pak for Data version 4.0.9 and later installed instances, and from IBM Cloud-managed instances.",
        "tags": [
          "Documents"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          },
          {
            "$ref": "#/components/parameters/docCountParam"
          },
          {
            "$ref": "#/components/parameters/docStatusParam"
          },
          {
            "$ref": "#/components/parameters/docHasNoticesParam"
          },
          {
            "$ref": "#/components/parameters/docIsParentParam"
          },
          {
            "$ref": "#/components/parameters/docParentDocIDParam"
          },
          {
            "$ref": "#/components/parameters/docSha256Param"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDocumentsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Missing project or collection.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/documents?status=available&version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "addDocument",
        "summary": "Add a document",
        "description": "Add a document to a collection with optional metadata.\n\nReturns immediately after the system has accepted the document for processing.\n\nUse this method to upload a file to the collection. You cannot use this method to crawl an external data source.\n\n * For a list of supported file types, see the [product documentation](/docs/discovery-data?topic=discovery-data-collections#supportedfiletypes).\n\n * You must provide document content, metadata, or both. If the request is missing both document content and metadata, it is rejected.\n\n  * You can set the **Content-Type** parameter on the **file** part to indicate the media type of the document. If the **Content-Type** parameter is missing or is one of the generic media types (for example, `application/octet-stream`), then the service attempts to automatically detect the document's media type.\n\n *  If the document is uploaded to a collection that shares its data with another collection, the **X-Watson-Discovery-Force** header must be set to `true`.\n\n * In curl requests only, you can assign an ID to a document that you add by appending the ID to the endpoint (`/v2/projects/{project_id}/collections/{collection_id}/documents/{document_id}`). If a document already exists with the specified ID, it is replaced.\n\nFor more information about how certain file types and field names are handled when a file is added to a collection, see the [product documentation](/docs/discovery-data?topic=discovery-data-index-overview#field-name-limits).",
        "tags": [
          "Documents"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          },
          {
            "$ref": "#/components/parameters/forceParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/AddDocument"
        },
        "responses": {
          "202": {
            "description": "The document has been accepted and will be processed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentAccepted"
                }
              }
            }
          },
          "400": {
            "description": "Bad request if the request is incorrectly formatted.\nThe error message contains details about what caused the request to be rejected.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden. Returned if you attempt to add a document to a collection in a read-only project.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found. Returned if you attempt to add a document to a project that doesn't exist or if the collection specified isn't part of the specified project.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "413": {
            "description": "Too large. Returned if you attempt to add a document or document metadata that exceeds the maximum possible.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported. Returned if the media type of the uploaded document is not supported by Discovery..",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--form \"file=@{filename}\"  \\\n",
                      "--form metadata=\"{\\\"field_name\\\": \\\"content\\\"}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/documents?version=2023-03-31\""
                    ]
                  },
                  {
                    "type": "markdown",
                    "source": [
                      "Download example document <a href=\"https://watson-developer-cloud.github.io/doc-tutorial-downloads/discovery/sample1.html\" target=\"_blank\" download=\"sample1.html\">sample1.html</a>"
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "\n",
                      "DetailedResponse<DocumentAccepted> result = null;\n",
                      "using (FileStream fs = File.OpenRead(\"path/to/file.pdf\"))\n",
                      "{\n",
                      "    using (MemoryStream ms = new MemoryStream())\n",
                      "    {\n",
                      "        fs.CopyTo(ms);\n",
                      "\n",
                      "        result = service.AddDocument(\n",
                      "            projectId: \"{project_id}\",\n",
                      "            collectionId: \"{collection_id}\",\n",
                      "            file: ms,\n",
                      "            filename: \"example-file\",\n",
                      "            fileContentType: \"application/pdf\"\n",
                      "            );\n",
                      "    }\n",
                      "}\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "File examplePdf = new File(\"path/to/file.pdf\");\n",
                      "\n",
                      "AddDocumentOptions options = new AddDocumentOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .collectionId(\"{collection_id}\")\n",
                      "  .file(examplePdf)\n",
                      "  .filename(\"example-file\")\n",
                      "  .fileContentType(\"application/pdf\")\n",
                      "  .build();\n",
                      "\n",
                      "DocumentAccepted response = discovery.addDocument(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const fs = require('fs');\n",
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  collectionId: '{collectionId}',\n",
                      "  file: fs.createReadStream('path/to/file.pdf'),\n",
                      "  filename: 'example-file',\n",
                      "  fileContentType: 'application/pdf',\n",
                      "};\n",
                      "\n",
                      "discovery.addDocument(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "import os\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "with open(os.path.join(os.getcwd(), '{path_element}', '{filename}'),'rb') as fileinfo:\n",
                      "  response = discovery.add_document(\n",
                      "    project_id='{project_id}',\n",
                      "    collection_id='{}',\n",
                      "    file=fileinfo,\n",
                      "    filename='example-file',\n",
                      "    file_content_type='application/pdf'\n",
                      "  ).get_result()\n",
                      "  print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}/documents/{document_id}": {
      "get": {
        "operationId": "getDocument",
        "summary": "Get document details",
        "description": "Get details about a specific document, whether the document is added by uploading a file or by crawling an external data source.\n\n**Note**: This method is available only from Cloud Pak for Data version 4.0.9 and later installed instances, and from IBM Cloud-managed instances.",
        "tags": [
          "Documents"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          },
          {
            "$ref": "#/components/parameters/documentIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the specified document details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentDetails"
                },
                "examples": {
                  "response": {
                    "value": {
                      "document_id": "4ffcfd8052005b99469e632506763bac_0",
                      "created": "2022-04-05T07:01:55.863Z",
                      "updated": "2022-04-21T06:27:26.509Z",
                      "status": "available",
                      "notices": [],
                      "children": {
                        "count": 0,
                        "have_notices": false
                      },
                      "filename": "Proposal.docx",
                      "file_type": "word"
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Missing project, collection, or document.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/documents/{document_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "updateDocument",
        "summary": "Update a document",
        "description": "Replace an existing document or add a document with a specified document ID. Starts ingesting a document with optional metadata.\n\nUse this method to upload a file to a collection. You cannot use this method to crawl an external data source.\n\nIf the document is uploaded to a collection that shares its data with another collection, the **X-Watson-Discovery-Force** header must be set to `true`.\n\n**Notes:**\n\n * Uploading a new document with this method automatically replaces any existing document stored with the same document ID.\n\n * If an uploaded document is split into child documents during ingestion, all existing child documents are overwritten, even if the updated version of the document has fewer child documents.",
        "tags": [
          "Documents"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          },
          {
            "$ref": "#/components/parameters/documentIdParam"
          },
          {
            "$ref": "#/components/parameters/forceParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/AddDocument"
        },
        "responses": {
          "202": {
            "description": "The document has been accepted and will be processed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentAccepted"
                }
              }
            }
          },
          "400": {
            "description": "Bad request if the request is incorrectly formatted.\nThe error message contains details about what caused the request to be rejected.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden. Returned if you attempt to add a document to a collection in a read-only project.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found. Returned if the project, collection, or document ID is missing or incorrect.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "413": {
            "description": "Too large. Returned if you attempt to add a document or document metadata that exceeds the maximum possible.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported. Returned if the media type of the uploaded document is not supported by Discovery..",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--form \"file=@{filename}\"  \\\n",
                      "--form metadata=\"{\\\"field_name\\\": \\\"content\\\"}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/documents/{document_id}?version=2023-03-31\""
                    ]
                  },
                  {
                    "type": "markdown",
                    "source": [
                      "Download example document <a href=\"https://watson-developer-cloud.github.io/doc-tutorial-downloads/discovery/sample1.html\" target=\"_blank\" download=\"sample1.html\">sample1.html</a>"
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.UpdateDocument(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    collectionId: \"{collection_id}\",\n",
                      "    documentId: \"{document_id}\",\n",
                      "    filename: \"updated-file-name\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "UpdateDocumentOptions options = new UpdateDocumentOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .collectionId(\"{collection_id}\")\n",
                      "  .documentId(\"{document_id}\")\n",
                      "  .metadata(\"{ \"metadata\": \"value\" }\")\n",
                      "  .build();\n",
                      "\n",
                      "DocumentAccepted response = discovery.updateDocument(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  collectionId: '{collectionId}',\n",
                      "  documentId: '{documentId}',\n",
                      "  metadata: '{\"metadata\": \"value\"}',\n",
                      "};\n",
                      "\n",
                      "discovery.updateDocument(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "import os\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "with open(os.path.join(os.getcwd(), '{path_element}', '{filename}'),'rb') as fileinfo:\n",
                      "  response = discovery.update_document(\n",
                      "    project_id='{project_id}',\n",
                      "    collection_id='{collection_id}',\n",
                      "    document_id='{document_id}',\n",
                      "    file=fileinfo,\n",
                      "    filename='example-file',\n",
                      "    fileinfo='application/pdf'\n",
                      "  ).get_result()\n",
                      "  print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteDocument",
        "summary": "Delete a document",
        "description": "Deletes the document with the document ID that you specify from the collection. Removes uploaded documents from the collection permanently. If you delete a document that was added by crawling an external data source, the document will be added again with the next scheduled crawl of the data source. The delete function removes the document from the collection, not from the external data source.\n\n**Note:** Files such as CSV or JSON files generate subdocuments when they are added to a collection. If you delete a subdocument, and then repeat the action that created it, the deleted document is added back in to your collection. To remove subdocuments that are generated by an uploaded file, delete the original document instead. You can get the document ID of the original document from the `parent_document_id` of the subdocument result.",
        "tags": [
          "Documents"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          },
          {
            "$ref": "#/components/parameters/documentIdParam"
          },
          {
            "$ref": "#/components/parameters/forceParam"
          }
        ],
        "responses": {
          "200": {
            "description": "The document was successfully deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteDocumentResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden. Returned if you attempt to delete a document in a collection that connects automatically to an external source.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found. Returned if the project, collection, or document ID is missing or incorrect.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/documents/{document_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.DeleteDocument(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    collectionId: \"{collection_id}\",\n",
                      "    documentId: \"{document_id}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "DeleteDocumentOptions options = new DeleteDocumentOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .collectionId(\"{collection_id}\")\n",
                      "  .documentId(\"{document_id}\")\n",
                      "  .build();\n",
                      "\n",
                      "DeleteDocumentResponse response = discovery.deleteDocument(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  collectionId: '{collectionId}',\n",
                      "  documentId: '{documentId}',\n",
                      "};\n",
                      "\n",
                      "discovery.deleteDocument(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.delete_document(\n",
                      "  project_id='{project_id}',\n",
                      "  collection_id='{collection_id}',\n",
                      "  document_id='{document_id}'\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}/notices": {
      "get": {
        "operationId": "queryCollectionNotices",
        "summary": "Query collection notices",
        "description": "Finds collection-level notices (errors and warnings) that are generated when documents are ingested.",
        "tags": [
          "Queries"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          },
          {
            "$ref": "#/components/parameters/filterParam"
          },
          {
            "$ref": "#/components/parameters/queryParam"
          },
          {
            "$ref": "#/components/parameters/nlqParam"
          },
          {
            "$ref": "#/components/parameters/countParam"
          },
          {
            "$ref": "#/components/parameters/offsetParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Query for collection notices executed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryNoticesResponse"
                },
                "examples": {
                  "response": {
                    "value": {
                      "matching_results": 48,
                      "notices": [
                        {
                          "severity": "warning",
                          "created": "2021-09-15T20:11:22Z",
                          "description": "We couldn't download the requested content from https://www.cdc.gov/coronavirus/2019-ncov/global-covid-19/essential-health-services.html because the request timed out.",
                          "step": "conversion",
                          "document_id": "9yJk9qKOQ",
                          "notice_id": "failed_crawl"
                        },
                        {
                          "severity": "warning",
                          "created": "2021-09-15T20:17:30Z",
                          "description": "We couldn't download the requested content from https://www.cdc.gov/coronavirus/2019-ncov/covid-data/covid-19-data-sources.html because the request timed out.",
                          "step": "conversion",
                          "document_id": "0xSkAIgmj",
                          "notice_id": "failed_crawl"
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} '{url}/v2/projects/{project_id}/collections/{collection_id}/notices?version=2023-03-31&query=notices.step:conversion&count=2'"
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.QueryCollectionNotices(\n",
                      "    projectId: \"{projectId}\",\n",
                      "    collectionId: \"{collectionId}\",\n",
                      "    query: \"notices.step:conversion&count=2\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "QueryCollectionNoticesOptions queryCollectionNoticesOptions = new QueryCollectionNoticesOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .collectionId(\"{collection_id}\")\n",
                      "  .naturalLanguageQuery(\"warning\")\n",
                      "  .build();\n",
                      "QueryNoticesResponse response = discovery.queryCollectionNotices(queryCollectionNoticesOptions).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  collectionId: '{collectionId}',\n",
                      "  query: 'notices.step:conversion&count=2',\n",
                      "};\n",
                      "\n",
                      "discovery.queryCollectionNotices(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.query_notices(\n",
                      "  project_id='{project_id}',\n",
                      "  collection_id='{collection_id}',\n",
                      "  query='notices.step:conversion&count=2'\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/training_data/queries": {
      "get": {
        "operationId": "listTrainingQueries",
        "summary": "List training queries",
        "description": "List the training queries for the specified project.",
        "tags": [
          "Training data"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Training data for the specified project found and returned.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrainingQuerySet"
                }
              }
            }
          },
          "404": {
            "description": "The specified project does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Request example",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/training_data/queries?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.ListTrainingQueries(\n",
                      "    projectId: \"{project_id}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "ListTrainingQueriesOptions options = new ListTrainingQueriesOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .build();\n",
                      "\n",
                      "TrainingQuerySet response = discovery.listTrainingQueries(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "};\n",
                      "\n",
                      "discovery.listTrainingQueries(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.list_training_queries(\n",
                      "  project_id='{project_id}'\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteTrainingQueries",
        "summary": "Delete training queries",
        "description": "Removes all training queries for the specified project.",
        "tags": [
          "Training data"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "All training data for the specified project has been deleted."
          },
          "400": {
            "description": "Invalid headers.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Incorrect project specified.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Request example",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/training_data/queries?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.DeleteTrainingQueries(\n",
                      "    projectId: \"{project_id}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "DeleteTrainingQueriesOptions options = new DeleteTrainingQueriesOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .build();\n",
                      "\n",
                      "discovery.deleteTrainingQueries(options).execute();"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "};\n",
                      "\n",
                      "discovery.deleteTrainingQueries(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.delete_training_queries(\n",
                      "  project_id='{project_id}'\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "createTrainingQuery",
        "summary": "Create a training query",
        "description": "Add a query to the training data for this project. The query can contain a filter and natural language query.\n\n**Note**: You cannot apply relevancy training to a `content_mining` project type.",
        "tags": [
          "Training data"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/AddTrainingQuery"
        },
        "responses": {
          "201": {
            "description": "The query was successfully added.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrainingQuery"
                }
              }
            }
          },
          "400": {
            "description": "Invalid headers or request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified project does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Request example",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--data \"{ \\\n",
                      "  \\\"natural_language_query\\\": \\\"why is the sky blue\\\", \\\n",
                      "  \\\"filter\\\": \\\"text:meteorology\\\", \\\n",
                      "  \\\"examples\\\": [{ \\\n",
                      "      \\\"document_id\\\": \\\"54f95ac0-3e4f-4756-bea6-7a67b2713c81\\\", \\\n",
                      "      \\\"relevance\\\": 1, \\\n",
                      "      \\\"collection_id\\\": \\\"800e58e4-198d-45eb-be87-74e1d6df4e96\\\" \\\n",
                      "  }, { \\\n",
                      "      \\\"document_id\\\": \\\"01bcca32-7300-4c9f-8d32-33ed7ea643da\\\", \\\n",
                      "      \\\"relevance\\\": 5, \\\n",
                      "      \\\"collection_id\\\": \\\"800e58e4-198d-45eb-be87-74e1d6df4e96\\\" \\\n",
                      "  }] \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/training_data/queries?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "TrainingExample trainingExample = new TrainingExample()\n",
                      "{\n",
                      "    CollectionId = \"{collection_id}\",\n",
                      "    DocumentId = \"{document_id}\"\n",
                      "};\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.CreateTrainingQuery(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    examples: new List<TrainingExample>() { trainingExample },\n",
                      "    naturalLanguageQuery: \"This is an example of a query\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "TrainingExample trainingExample = new TrainingExample.Builder()\n",
                      "  .collectionId(\"{collection_id}\")\n",
                      "  .documentId(\"{document_id}\")\n",
                      "  .relevance(1L)\n",
                      "  .build();\n",
                      "\n",
                      "CreateTrainingQueryOptions options = new CreateTrainingQueryOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .addExamples(trainingExample)\n",
                      "  .naturalLanguageQuery(\"This is an example of a query\")\n",
                      "  .build();\n",
                      "\n",
                      "TrainingQuery response = discovery.createTrainingQuery(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  naturalLanguageQuery: 'This is an example of a query',\n",
                      "  examples: [\n",
                      "    {\n",
                      "      collection_id: '{collectionId}',\n",
                      "      document_id: '{documentId}',\n",
                      "    },\n",
                      "  ],\n",
                      "};\n",
                      "\n",
                      "discovery.createTrainingQuery(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_watson.discovery_v2 import TrainingExample\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "training_example = TrainingExample(\n",
                      "  document_id='{document_id}',\n",
                      "  collection_id='{collection_id}',\n",
                      "  relevance=1\n",
                      ")\n",
                      "response = discovery.create_training_query(\n",
                      "  project_id='{project_id}',\n",
                      "  natural_language_query='This is an example of a query',\n",
                      "  examples=[training_example]\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/training_data/queries/{query_id}": {
      "get": {
        "operationId": "getTrainingQuery",
        "summary": "Get a training data query",
        "description": "Get details for a specific training data query, including the query string and all examples",
        "tags": [
          "Training data"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/trainingQueryIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Details of the specified training query.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrainingQuery"
                }
              }
            }
          },
          "404": {
            "description": "Query or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Request example",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/training_data/queries/{query_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.GetTrainingQuery(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    queryId: \"{query_id}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "GetTrainingQueryOptions options = new GetTrainingQueryOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .queryId(\"{query_id}\")\n",
                      "  .build();\n",
                      "\n",
                      "TrainingQuery response = discovery.getTrainingQuery(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  queryId: '{queryId}',\n",
                      "};\n",
                      "\n",
                      "discovery.getTrainingQuery(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.get_training_query(\n",
                      "  project_id='{project_id}',\n",
                      "  query_id='{query_id}'\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "updateTrainingQuery",
        "summary": "Update a training query",
        "description": "Updates an existing training query and its examples. You must resubmit all of the examples with the update request.",
        "tags": [
          "Training data"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/trainingQueryIdParam"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TrainingQuery"
              }
            }
          },
          "description": "The body of the example that is to be added to the specified query.",
          "required": true
        },
        "x-codegen-request-body-name": "body",
        "responses": {
          "201": {
            "description": "The example was successfully added to the query.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrainingQuery"
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Request example",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--data \"{ \\\n",
                      "  \\\"query_id\\\": \\\"3c4fff84-1500-455c-b125-eaa2d319f6d3\\\", \\\n",
                      "  \\\"natural_language_query\\\": \\\"why is the sky blue\\\", \\\n",
                      "  \\\"filter\\\": \\\"text:meteorology\\\", \\\n",
                      "  \\\"examples\\\": [{ \\\n",
                      "      \\\"document_id\\\": \\\"54f95ac0-3e4f-4756-bea6-7a67b2713c81\\\", \\\n",
                      "      \\\"relevance\\\": 1, \\\n",
                      "      \\\"collection_id\\\": \\\"800e58e4-198d-45eb-be87-74e1d6df4e96\\\" \\\n",
                      "  }, { \\\n",
                      "      \\\"document_id\\\": \\\"01bcca32-7300-4c9f-8d32-33ed7ea643da\\\", \\\n",
                      "      \\\"relevance\\\": 5, \\\n",
                      "      \\\"collection_id\\\": \\\"800e58e4-198d-45eb-be87-74e1d6df4e96\\\" \\\n",
                      "  }] \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/training_data/queries/{query_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var newFilter = \"field:1\";\n",
                      "TrainingExample newTrainingExample = new TrainingExample()\n",
                      "{\n",
                      "    CollectionId = \"{collection_id}\",\n",
                      "    DocumentId = \"{document_id}\"\n",
                      "};\n",
                      "\n",
                      "var result = service.UpdateTrainingQuery(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    queryId: \"{query_id}\",\n",
                      "    naturalLanguageQuery: \"This is a new example of a query\",\n",
                      "    examples: new List<TrainingExample>() { newTrainingExample },\n",
                      "    filter: newFilter\n",
                      "    );"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "TrainingExample newTrainingExample = new TrainingExample.Builder()\n",
                      "  .collectionId(\"{collection_id}\")\n",
                      "  .documentId(\"{document_id}\")\n",
                      "  .relevance(1L)\n",
                      "  .build();\n",
                      "String newQuery = \"This is a new query!\";\n",
                      "\n",
                      "UpdateTrainingQueryOptions options = new UpdateTrainingQueryOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .queryId(\"{query_id}\")\n",
                      "  .addExamples(newTrainingExample)\n",
                      "  .naturalLanguageQuery(newQuery)\n",
                      "  .build();\n",
                      "\n",
                      "TrainingQuery response = discovery.updateTrainingQuery(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  queryId: '{queryId}',\n",
                      "  naturalLanguageQuery: 'This is a new query!',\n",
                      "  examples: [\n",
                      "    {\n",
                      "      document_id: '{documentId}',\n",
                      "      collection_id: '{collectionId}',\n",
                      "      relevance: 1,\n",
                      "    },\n",
                      "  ],\n",
                      "};\n",
                      "\n",
                      "discovery.updateTrainingQuery(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_watson.discovery_v2 import TrainingExample\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "training_example = TrainingExample(\n",
                      "  document_id='{document_id}',\n",
                      "  collection_id='{collection_id}',\n",
                      "  relevance=1\n",
                      ")\n",
                      "response = discovery.update_training_query(\n",
                      "  project_id='{project_id}',\n",
                      "  query_id='{query_id}',\n",
                      "  natural_language_query='This is an example of a query',\n",
                      "  examples=[training_example],\n",
                      "  filter='{field:1}'\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteTrainingQuery",
        "summary": "Delete a training data query",
        "description": "Removes details from a training data query, including the query string and all examples.\n\nTo delete an example, use the *Update a training query* method and omit the example that you want to delete from the example set.",
        "tags": [
          "Training data"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/trainingQueryIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "The query and all example document references were successfully removed from the training set for this collection."
          },
          "404": {
            "description": "Query or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Request example",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/training_data/queries/{query_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.DeleteTrainingQuery(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    queryId: \"{query_id}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "DeleteTrainingQueryOptions deleteTrainingQueryOptions = new DeleteTrainingQueryOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .queryId(\"{query_id}\")\n",
                      "  .build();\n",
                      "\n",
                      "discovery.deleteTrainingQuery(deleteTrainingQueryOptions).execute().getResult();"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  queryId: '{queryId}',\n",
                      "};\n",
                      "\n",
                      "discovery.deleteTrainingQuery(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.delete_training_query(\n",
                      "  project_id='{project_id}',\n",
                      "  query_id='{query_id}'\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/notices": {
      "get": {
        "operationId": "queryNotices",
        "summary": "Query project notices",
        "description": "Finds project-level notices (errors and warnings). Currently, project-level notices are generated by relevancy training.",
        "tags": [
          "Queries"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/filterParam"
          },
          {
            "$ref": "#/components/parameters/queryParam"
          },
          {
            "$ref": "#/components/parameters/nlqParam"
          },
          {
            "$ref": "#/components/parameters/countParam"
          },
          {
            "$ref": "#/components/parameters/offsetParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Query for project notices executed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryNoticesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/notices?natural_language_query=error&version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.QueryNotices(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    query: \"{field}:{value}\"\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "QueryNoticesOptions options = new QueryNoticesOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .query(\"{field}:{value}\")\n",
                      "  .build();\n",
                      "\n",
                      "QueryNoticesResponse response = discovery.queryNotices(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  query: '{field}:{value}',\n",
                      "};\n",
                      "\n",
                      "discovery.queryNotices(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.query_notices(\n",
                      "  project_id='{project_id}',\n",
                      "  query='{field}:{value}'\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}/stopwords": {
      "get": {
        "tags": [
          "Query modifications"
        ],
        "operationId": "getStopwordList",
        "summary": "Get a custom stop words list",
        "description": "Returns the custom stop words list that is used by the collection. For information about the default stop words lists that are applied to queries, see [the product documentation](/docs/discovery-data?topic=discovery-data-stopwords).",
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "List of custom stop words or an empty array if no custom stop words list is applied to the collection.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StopWordList"
                },
                "examples": {
                  "response": {
                    "value": {
                      "stopwords": []
                    }
                  }
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/stopwords?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "tags": [
          "Query modifications"
        ],
        "operationId": "createStopwordList",
        "summary": "Create a custom stop words list",
        "description": "Adds a list of custom stop words. Stop words are words that you want the service to ignore when they occur in a query because they're not useful in distinguishing the semantic meaning of the query. The stop words list cannot contain more than 1 million characters.\n\nA default stop words list is used by all collections. The default list is applied both at indexing time and at query time. A custom stop words list that you add is used at query time only.\n\nThe custom stop words list augments the default stop words list; you cannot remove stop words. For information about the default stop words lists per language, see [the product documentation](/docs/discovery-data?topic=discovery-data-stopwords).",
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StopWordList"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The array of custom stop words that are applied to the collection.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StopWordList"
                },
                "examples": {
                  "response": {
                    "value": {
                      "stopwords": [
                        "a",
                        "about",
                        "again",
                        "am",
                        "an",
                        "and",
                        "any",
                        "are",
                        "as",
                        "at",
                        "be",
                        "because",
                        "been",
                        "being",
                        "between",
                        "both",
                        "but",
                        "by"
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.\n\n* Unable to create stop words because request body was not valid JSON or was incorrect JSON.\n\n* Stopword creation request contained no stopwords.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Could not find named collection.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "413": {
            "description": "Input stopwords file is too large. Input must be less than 1000000 characters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"stopwords\\\": [  \\\n",
                      "    \\\"a\\\", \\\n",
                      "    \\\"about\\\", \\\n",
                      "    \\\"again\\\", \\\n",
                      "    \\\"am\\\", \\\n",
                      "    \\\"an\\\", \\\n",
                      "    \\\"and\\\", \\\n",
                      "    \\\"any\\\", \\\n",
                      "    \\\"are\\\", \\\n",
                      "    \\\"as\\\", \\\n",
                      "    \\\"at\\\", \\\n",
                      "    \\\"be\\\", \\\n",
                      "    \\\"because\\\", \\\n",
                      "    \\\"been\\\", \\\n",
                      "    \\\"being\\\", \\\n",
                      "    \\\"between\\\", \\\n",
                      "    \\\"both\\\", \\\n",
                      "    \\\"but\\\", \\\n",
                      "    \\\"by\\\" \\\n",
                      "  ] \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/stopwords?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "tags": [
          "Query modifications"
        ],
        "operationId": "deleteStopwordList",
        "summary": "Delete a custom stop words list",
        "description": "Deletes a custom stop words list to stop using it in queries against the collection. After a custom stop words list is deleted, the default stop words list is used.",
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "The custom stop words list was deleted."
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/stopwords?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}/expansions": {
      "get": {
        "operationId": "listExpansions",
        "summary": "Get the expansion list",
        "description": "Returns the current expansion list for the specified collection. If an expansion list is not specified, an empty expansions array is returned.",
        "tags": [
          "Query modifications"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully fetched expansion details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Expansions"
                },
                "examples": {
                  "response": {
                    "value": {
                      "expansions": []
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request if the request is incorrectly formatted.\nThe error message contains details about what caused the request to be rejected.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/expansions?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "createExpansions",
        "summary": "Create or update an expansion list",
        "description": "Creates or replaces the expansion list for this collection. An expansion list introduces alternative wording for key terms that are mentioned in your collection. By identifying synonyms or common misspellings, you expand the scope of a query beyond exact matches. The maximum number of expanded terms allowed per collection is 5,000.",
        "tags": [
          "Query modifications"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Expansions"
              }
            }
          },
          "description": "An object that defines the expansion list.",
          "required": true
        },
        "x-codegen-request-body-name": "body",
        "responses": {
          "200": {
            "description": "The expansion list has been accepted and will be used for all future queries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Expansions"
                },
                "examples": {
                  "response": {
                    "value": {
                      "expansions": [
                        {
                          "input_terms": [
                            "on premise"
                          ],
                          "expanded_terms": [
                            "on premises",
                            "on-premises"
                          ]
                        },
                        {
                          "input_terms": [
                            "car"
                          ],
                          "expanded_terms": [
                            "car",
                            "automobile",
                            "vehicle"
                          ]
                        },
                        {
                          "expanded_terms": [
                            "ibm",
                            "international business machines",
                            "big blue"
                          ]
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.\n\n* Unable to create expansions because request body was not valid JSON or was incorrect JSON.\n\n* Query expansion creation request contained no expansions.\n\n* Request exceeded expansion mappings limit.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Could not find named collection.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"expansions\\\": [  \\\n",
                      "   { \\\n",
                      "     \\\"input_terms\\\": [ \\\n",
                      "       \\\"on premise\\\" \\\n",
                      "     ], \\\n",
                      "     \\\"expanded_terms\\\": [  \\\n",
                      "       \\\"on premises\\\", \\\n",
                      "       \\\"on-premises\\\" \\\n",
                      "     ] \\\n",
                      "   }, \\\n",
                      "   { \\\n",
                      "     \\\"input_terms\\\": [ \\\n",
                      "       \\\"car\\\" \\\n",
                      "     ], \\\n",
                      "     \\\"expanded_terms\\\": [  \\\n",
                      "       \\\"car\\\", \\\n",
                      "       \\\"automobile\\\", \\\n",
                      "       \\\"vehicle\\\" \\\n",
                      "     ] \\\n",
                      "   }, \\\n",
                      "   { \\\n",
                      "     \\\"expanded_terms\\\": [  \\\n",
                      "       \\\"ibm\\\", \\\n",
                      "       \\\"international business machines\\\", \\\n",
                      "       \\\"big blue\\\" \\\n",
                      "     ] \\\n",
                      "   } \\\n",
                      "  ] \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/expansions?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteExpansions",
        "summary": "Delete the expansion list",
        "description": "Removes the expansion information for this collection. To disable query expansion for a collection, delete the expansion list.",
        "tags": [
          "Query modifications"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "The expansion list was successfully deleted."
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/expansions?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/curations": {
      "get": {
        "operationId": "listCurations",
        "summary": "List curations",
        "description": "Lists the currently configured curation queries and the associated curated responses. The curations API methods are **beta** functionality. Beta features are not supported by the SDKs.",
        "tags": [
          "Curations"
        ],
        "x-ibm-release-level": "beta",
        "x-sdk-exclude": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "List of curations associated  with the specified project.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Curations"
                },
                "examples": {
                  "response": {
                    "value": {
                      "curations": [
                        {
                          "curation_id": "a3dd3f517283be53c7a05013213450d960635334",
                          "natural_language_query": "What types of data sources are supported",
                          "curated_results": [
                            {
                              "collection_id": "47477591-b520-6039-0000-017ea213e837",
                              "document_id": "web_crawl_b43bc2d2-9445-51b1-ab1d-57459c7446ce"
                            }
                          ]
                        },
                        {
                          "curation_id": "c1175536f509405bc68a9f76235fa7bbb6f9af2f",
                          "natural_language_query": "What is a project",
                          "curated_results": [
                            {
                              "collection_id": "47477591-b520-6039-0000-017ea213e837",
                              "document_id": "web_crawl_123a2a56-8c26-5acb-9544-c4702ac899a4",
                              "snippet": "A project is a convenient way to collect and manage the resources in your application. You can assign a project type and connect your data to the project by creating a collection."
                            }
                          ]
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/curations?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "createCuration",
        "summary": "Create curation",
        "description": "Add a new curated query and specify result documents. Curations with a total of 5,000 queries and 50,000 documents are allowed per project.\n\n**Note**: The curations API methods are **beta** functionality. Beta features are not supported by the SDKs.",
        "tags": [
          "Curations"
        ],
        "x-ibm-release-level": "beta",
        "x-sdk-exclude": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Curation"
              }
            }
          },
          "description": "Natural language query to curate and array of results to return when the query is specified.",
          "required": true
        },
        "responses": {
          "201": {
            "description": "Curation that has been created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Curation"
                },
                "examples": {
                  "response": {
                    "value": {
                      "curation_id": "c1175536f509405bc68a9f76235fa7bbb6f9af2f",
                      "natural_language_query": "What is a project",
                      "curated_results": [
                        {
                          "collection_id": "47477591-b520-6039-0000-017ea213e837",
                          "document_id": "web_crawl_123a2a56-8c26-5acb-9544-c4702ac899a4",
                          "snippet": "A project is a convenient way to collect and manage the resources in your application. You can assign a project type and connect your data to the project by creating a collection."
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Specified natural language query already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified project, collection, or document not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"natural_language_query\\\": \\\"What is a project\\\", \\\n",
                      "  \\\"curated_results\\\": [{ \\\n",
                      "    \\\"document_id\\\": \\\"web_crawl_123a2a56-8c26-5acb-9544-c4702ac899a4\\\", \\\n",
                      "    \\\"collection_id\\\": \\\"47477591-b520-6039-0000-017ea213e837\\\", \\\n",
                      "    \\\"snippet\\\": \\\"A project is a convenient way to collect and manage the resources in your application. You can assign a project type and connect your data to the project by creating a collection.\\\" \\\n",
                      "  }] \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/curations?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/curations/{curation_id}": {
      "get": {
        "operationId": "getCuration",
        "summary": "Get curation",
        "description": "Gets details about the specified curation. The curations API methods are **beta** functionality. Beta features are not supported by the SDKs.",
        "tags": [
          "Curations"
        ],
        "x-ibm-release-level": "beta",
        "x-sdk-exclude": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/curationIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Object that contains an array of curated results for the specified curation id.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CuratedResults"
                },
                "examples": {
                  "response": {
                    "value": {
                      "curated_results": [
                        {
                          "collection_id": "47477591-b520-6039-0000-017ea213e837",
                          "document_id": "web_crawl_b43bc2d2-9445-51b1-ab1d-57459c7446ce"
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified project or curation ID not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/3d8e91bc-a277-41b5-aa1e-c39327bc15bf/curations/a3dd3f517283be53c7a05013213450d960635334?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteCuration",
        "summary": "Delete curation",
        "description": "Deletes the specified curation. The curations API methods are **beta** functionality. Beta features are not supported by the SDKs.",
        "tags": [
          "Curations"
        ],
        "x-ibm-release-level": "beta",
        "x-sdk-exclude": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/curationIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Curation has been successfully deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CurationStatus"
                }
              }
            }
          },
          "404": {
            "description": "Specified project or curation id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/3d8e91bc-a277-41b5-aa1e-c39327bc15bf/curations/c1175536f509405bc68a9f76235fa7bbb6f9af2f?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/curations/{curation_id}/curated_results": {
      "post": {
        "operationId": "updateCurationResults",
        "summary": "Update curation results",
        "description": "Update an existing curated results documents for the specified query. For example, you can enhance the curated result by adding a text snippet to it. The curations API methods are **beta** functionality. Beta features are not supported by the SDKs.",
        "tags": [
          "Curations"
        ],
        "x-ibm-release-level": "beta",
        "x-sdk-exclude": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/curationIdParam"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CurationResult"
              }
            }
          },
          "description": "Result to add to the specified curated query.",
          "required": true
        },
        "responses": {
          "201": {
            "description": "Result has been added to the curation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CurationResult"
                },
                "examples": {
                  "response": {
                    "value": {
                      "collection_id": "47477591-b520-6039-0000-017ea213e837",
                      "document_id": "web_crawl_b43bc2d2-9445-51b1-ab1d-57459c7446ce",
                      "snippet": "Watson Discovery can get data from many popular third-party data repositories. See the \"Supported data sources\" table for more details."
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Specified document ID already exists in this curation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified project, collection or document not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--data \"{ \\\n",
                      "  \\\"document_id\\\": \\\"web_crawl_b43bc2d2-9445-51b1-ab1d-57459c7446ce\\\",  \\\n",
                      "  \\\"collection_id\\\": \\\"47477591-b520-6039-0000-017ea213e837\\\", \\\n",
                      "  \\\"snippet\\\": \\\"Watson Discovery can get data from many popular third-party data repositories. See the \\\"Supported data sources\\\" table for more details.\\\"}\" \\\n",
                      "\"{url}/v2/projects/3d8e91bc-a277-41b5-aa1e-c39327bc15bf/curations/a3dd3f517283be53c7a05013213450d960635334/curated_results?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects": {
      "get": {
        "operationId": "listProjects",
        "summary": "List projects",
        "description": "Lists existing projects for this instance.",
        "tags": [
          "Projects"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListProjectsResponse"
                },
                "examples": {
                  "response": {
                    "value": {
                      "projects": [
                        {
                          "project_id": "fe119406-4111-4cd8-8418-6f0074ee5a12",
                          "type": "document_retrieval",
                          "name": "Sample Project",
                          "collection_count": 1
                        },
                        {
                          "project_id": "b1722e7b-0b42-4fce-a6a4-d7cd8a4895f1",
                          "type": "document_retrieval",
                          "name": "My search bar",
                          "collection_count": 5
                        },
                        {
                          "project_id": "c8a8f4f1-9bcb-4035-85ae-5ec2336f2e62",
                          "type": "conversational_search",
                          "name": "Tutorial project",
                          "collection_count": 1
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "createProject",
        "summary": "Create a project",
        "description": "Create a new project for this instance",
        "tags": [
          "Projects"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/CreateProject"
        },
        "responses": {
          "201": {
            "description": "The project has successfully been created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectDetails"
                },
                "examples": {
                  "response": {
                    "value": {
                      "project_id": "6b18887d-d68e-434d-99f1-20925c7654e0",
                      "type": "document_retrieval",
                      "name": "My project",
                      "collection_count": 0,
                      "default_query_parameters": {
                        "aggregation": "[term(enriched_text.entities.text,name:entities)]",
                        "count": 10,
                        "sort": "",
                        "return": [],
                        "passages": {
                          "enabled": true,
                          "count": 10,
                          "fields": [
                            "text",
                            "title"
                          ],
                          "characters": 200,
                          "per_document": true,
                          "max_per_document": 1,
                          "find_answers": false,
                          "max_answers_per_passage": 1
                        },
                        "highlight": false,
                        "spelling_suggestions": false,
                        "table_results": {
                          "enabled": false,
                          "count": 10,
                          "per_document": 0
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"name\\\": \\\"My project\\\", \\\n",
                      "  \\\"type\\\": \\\"document_retrieval\\\" \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}": {
      "get": {
        "operationId": "getProject",
        "summary": "Get project",
        "description": "Get details on the specified project.",
        "tags": [
          "Projects"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns information about the specified project if it exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectDetails"
                },
                "examples": {
                  "response": {
                    "value": {
                      "project_id": "6b18887d-d68e-434d-99f1-20925c7654e0",
                      "type": "document_retrieval",
                      "name": "My project",
                      "collection_count": 0,
                      "relevancy_training_status": {
                        "total_examples": 0,
                        "sufficient_label_diversity": false,
                        "processing": false,
                        "minimum_examples_added": false,
                        "available": false,
                        "notices": 0,
                        "minimum_queries_added": false
                      },
                      "default_query_parameters": {
                        "aggregation": "[term(enriched_text.entities.text,name:entities)]",
                        "count": 10,
                        "sort": "",
                        "return": [],
                        "passages": {
                          "enabled": true,
                          "count": 10,
                          "fields": [
                            "text",
                            "title"
                          ],
                          "characters": 200,
                          "per_document": true,
                          "max_per_document": 1,
                          "find_answers": false,
                          "max_answers_per_passage": 1
                        },
                        "highlight": false,
                        "spelling_suggestions": false,
                        "table_results": {
                          "enabled": false,
                          "count": 10,
                          "per_document": 0
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "updateProject",
        "summary": "Update a project",
        "description": "Update the specified project's name.",
        "tags": [
          "Projects"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ProjectName"
        },
        "responses": {
          "200": {
            "description": "Returns the updated project information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectDetails"
                },
                "examples": {
                  "response": {
                    "value": {
                      "project_id": "6b18887d-d68e-434d-99f1-20925c7654e0",
                      "type": "document_retrieval",
                      "name": "My updated project",
                      "collection_count": 0,
                      "relevancy_training_status": {
                        "total_examples": 0,
                        "sufficient_label_diversity": false,
                        "processing": false,
                        "minimum_examples_added": false,
                        "available": false,
                        "notices": 0,
                        "minimum_queries_added": false
                      },
                      "default_query_parameters": {
                        "aggregation": "[term(enriched_text.entities.text,name:entities)]",
                        "count": 10,
                        "sort": "",
                        "return": [],
                        "passages": {
                          "enabled": true,
                          "count": 10,
                          "fields": [
                            "text",
                            "title"
                          ],
                          "characters": 200,
                          "per_document": true,
                          "max_per_document": 1,
                          "find_answers": false,
                          "max_answers_per_passage": 1
                        },
                        "highlight": false,
                        "spelling_suggestions": false,
                        "table_results": {
                          "enabled": false,
                          "count": 10,
                          "per_document": 0
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Project not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"name\\\": \\\"My updated project\\\" \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteProject",
        "summary": "Delete a project",
        "description": "Deletes the specified project. \n\n**Important:** Deleting a project deletes everything that is part of the specified project, including all collections.",
        "tags": [
          "Projects"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "The project has been deleted."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Project not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/fields": {
      "get": {
        "operationId": "listFields",
        "summary": "List fields",
        "description": "Gets a list of the unique fields (and their types) stored in the specified collections.",
        "tags": [
          "Projects"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdsParam"
          }
        ],
        "responses": {
          "200": {
            "description": "The list of fetched fields.\n\nThe fields are returned using a fully qualified name format, however, the format differs slightly from that used by the query operations:\n\n  * Fields which contain nested JSON objects are assigned a type of \"nested\".\n\n  * Fields which belong to a nested object are prefixed with `.properties` (for example, `warnings.properties.severity` means that the `warnings` object has a property called `severity`).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListFieldsResponse"
                },
                "examples": {
                  "response": {
                    "value": {
                      "fields": [
                        {
                          "field": "enriched_text",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "nested"
                        },
                        {
                          "field": "enriched_text.entities",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "nested"
                        },
                        {
                          "field": "enriched_text.entities.mentions",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "nested"
                        },
                        {
                          "field": "enriched_text.entities.mentions.location.begin",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "double"
                        },
                        {
                          "field": "enriched_text.entities.mentions.location.end",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "double"
                        },
                        {
                          "field": "enriched_text.entities.mentions.text",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "enriched_text.entities.model_name",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "enriched_text.entities.text",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "enriched_text.entities.type",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "extracted_metadata.file_type",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "extracted_metadata.filename",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "extracted_metadata.numPages",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "extracted_metadata.publicationdate",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "date"
                        },
                        {
                          "field": "extracted_metadata.sha1",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "metadata",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "nested"
                        },
                        {
                          "field": "metadata.customer_id",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "metadata.parent_document_id",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "text",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        },
                        {
                          "field": "document_id",
                          "collection_id": "a3a41b30-8336-dc17-0000-017b75119cfe",
                          "type": "string"
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/fields?collection_ids={collection_id_1},{collection_id_2}&version=2023-03-31\""
                    ]
                  }
                ]
              }
            ],
            "dotnet-standard": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\n",
                      "    url: \"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\",\n",
                      "    username: \"{username}\",\n",
                      "    password: \"{password}\"\n",
                      "    );\n",
                      "\n",
                      "DiscoveryService service = new DiscoveryService(\"2020-08-30\", authenticator);\n",
                      "service.SetServiceUrl(\"{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}\");\n",
                      "\n",
                      "var result = service.ListFields(\n",
                      "    projectId: \"{project_id}\",\n",
                      "    collectionIds: new List<string>() { \"{collection_id_1}\",\"{collection_id_2}\" }\n",
                      "    );\n",
                      "\n",
                      "Console.WriteLine(result.Response);"
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "ListFieldsOptions options = new ListFieldsOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .addCollectionIds(\"{collection_id_1}\")\n",
                      "  .addCollectionIds(\"{collection_id_2}\")\n",
                      "  .build();\n",
                      "\n",
                      "ListFieldsResponse response = discovery.listFields(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  collectionIds: ['{collection_id_1}','{collection_id_2}'],\n",
                      "};\n",
                      "\n",
                      "discovery.listFields(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.list_fields(\n",
                      "  project_id='{project_id}',\n",
                      "  collection_ids=['{collection_id_1}','{collection_id_2}']\n",
                      ").get_result()\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/enrichments": {
      "get": {
        "operationId": "listEnrichments",
        "summary": "List enrichments",
        "description": "Lists the enrichments available to this project. The *Part of Speech* and *Sentiment of Phrases* enrichments might be listed, but are reserved for internal use only.",
        "tags": [
          "Enrichments"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns an array of available enrichments.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Enrichments"
                },
                "examples": {
                  "response": {
                    "value": {
                      "enrichments": [
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000016",
                          "name": "Sentiment of Document",
                          "type": "natural_language_understanding",
                          "description": "Predict document-level sentiment"
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000018",
                          "name": "Keywords",
                          "type": "natural_language_understanding",
                          "description": "Extract keywords from each document"
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000012",
                          "name": "Table Understanding",
                          "type": "rule_based",
                          "description": "Understand tabular data in HTML via understanding of each table's column headers, row headers, body cells, as well as relevant context and title"
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-00000000001e",
                          "name": "Entities v2",
                          "type": "natural_language_understanding",
                          "description": "Extract named entities from each document with v2 type system"
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000004",
                          "name": "Sentiment of Phrases",
                          "type": "sentiment",
                          "description": "Extract phrases and expressions which convey sentiment."
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000017",
                          "name": "Entities v1 legacy",
                          "type": "natural_language_understanding",
                          "description": "Extract named entities from each document with v1 type system"
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000002",
                          "name": "Part of Speech",
                          "type": "part_of_speech",
                          "description": "Extract words and phrases from unstructured content and mark these extractions as annotations."
                        },
                        {
                          "enrichment_id": "314567a0-2bf7-11ee-be56-0242ac120002",
                          "name": "Sentence Classification",
                          "type": "sentence_classifier",
                          "description": "Classify sentences from each document"
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Project not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/enrichments?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "createEnrichment",
        "summary": "Create an enrichment",
        "description": "Create an enrichment for use with the specified project. To apply the enrichment to a collection in the project, use the [Collections API](/apidocs/discovery-data#createcollection).",
        "tags": [
          "Enrichments"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/EnrichmentDetails"
        },
        "responses": {
          "201": {
            "description": "The enrichment has been successfully created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Enrichment"
                },
                "examples": {
                  "response": {
                    "value": {
                      "enrichment_id": "5b36383b-fa57-0bfe-0000-017b77fba220",
                      "name": "Products",
                      "type": "dictionary",
                      "description": "Products dictionary",
                      "options": {
                        "languages": [
                          "en"
                        ],
                        "entity_type": "products"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: multipart/form-data\" \\\n",
                      "--form enrichment=\"{\\\"name\\\": \\\"Products\\\", \\\n",
                      "  \\\"type\\\": \\\"dictionary\\\", \\\n",
                      "  \\\"description\\\": \\\"Products dictionary\\\", \\\n",
                      "  \\\"options\\\": {\\\"languages\\\": [\\\"en\\\"], \\\"entity_type\\\": \\\"products\\\"}}\" \\\n",
                      "--form file=@product_list.csv \\\n",
                      "\"{url}/v2/projects/{project_id}/enrichments?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/enrichments/{enrichment_id}": {
      "get": {
        "operationId": "getEnrichment",
        "summary": "Get enrichment",
        "description": "Get details about a specific enrichment.",
        "tags": [
          "Enrichments"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/enrichmentIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns information about the specified enrichment.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Enrichment"
                },
                "examples": {
                  "response": {
                    "value": {
                      "enrichment_id": "5b36383b-fa57-0bfe-0000-017b77fba220",
                      "name": "Products",
                      "type": "dictionary",
                      "description": "Products dictionary",
                      "options": {
                        "languages": [
                          "en"
                        ],
                        "entity_type": "products"
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Enrichment or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/enrichments/{enrichment_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "updateEnrichment",
        "summary": "Update an enrichment",
        "description": "Updates an existing enrichment's name and description.",
        "tags": [
          "Enrichments"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/enrichmentIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/EnrichmentUpdate"
        },
        "responses": {
          "200": {
            "description": "Returns the updated enrichment details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Enrichment"
                },
                "examples": {
                  "response": {
                    "value": {
                      "enrichment_id": "5b36383b-fa57-0bfe-0000-017b77fba220",
                      "name": "Products and Services",
                      "type": "dictionary",
                      "description": "Products dictionary",
                      "options": {
                        "languages": [
                          "en"
                        ],
                        "entity_type": "products"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Enrichment or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"name\\\": \\\"Products and Services\\\" \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/enrichments/{enrichment_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteEnrichment",
        "summary": "Delete an enrichment",
        "description": "Deletes an existing enrichment from the specified project. \n\n**Note:** Only enrichments that have been manually created can be deleted.",
        "tags": [
          "Enrichments"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/enrichmentIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "The enrichment has been successfully deleted"
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Enrichment or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/enrichments/{enrichment_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/document_classifiers": {
      "get": {
        "operationId": "listDocumentClassifiers",
        "summary": "List document classifiers",
        "description": "Get a list of the document classifiers in a project. Returns only the name and classifier ID of each document classifier.",
        "tags": [
          "Document classifiers"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns a list of document classifiers.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentClassifiers"
                },
                "examples": {
                  "response": {
                    "value": {
                      "classifiers": [
                        {
                          "name": "Customer comments classifier",
                          "classifier_id": "0e36fdd2-7fb0-812b-0000-017ed29d6587"
                        },
                        {
                          "name": "Product feedback classification",
                          "classifier_id": "357f301e-e918-0b73-0000-017e8983070c"
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Document project is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "createDocumentClassifier",
        "summary": "Create a document classifier",
        "description": "Create a document classifier. You can use the API to create a document classifier in any project type. After you create a document classifier, you can use the Enrichments API to create a classifier enrichment, and then the Collections API to apply the enrichment to a collection in the project.\n\n**Note:** This method is supported on installed instances (IBM Cloud Pak for Data) or IBM Cloud-managed Premium or Enterprise plan instances.",
        "tags": [
          "Document classifiers"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/DocumentClassifierCreate"
        },
        "responses": {
          "201": {
            "description": "Returns the document classifier details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentClassifier"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Customer comments classifier",
                      "classifier_id": "0e36fdd2-7fb0-812b-0000-017ed29d6587",
                      "description": "User reviews",
                      "created": "2022-03-09T17:51:51.592Z",
                      "language": "en",
                      "enrichments": [
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-00000000001e",
                          "fields": [
                            "text",
                            "body"
                          ]
                        }
                      ],
                      "answer_field": "label",
                      "recognized_fields": [
                        "text",
                        "body",
                        "date",
                        "client_age",
                        "client_location",
                        "label",
                        "type_column",
                        "client_segment",
                        "claim_id",
                        "claim_product",
                        "claim_product_line"
                      ],
                      "training_data_file": "training.csv",
                      "test_data_file": "test.csv",
                      "federated_classification": {
                        "field": "claim_product_line"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request. A required parameter is null or invalid. Specific failure messages include:\n* No request body (missing classifier configuration).\n* Missing required request parameter or its value.\n* Unsupported language is requested.\n* Provided `training_data` or `test_data` does not have field requested in `answer_field`.\n* Requested enrichment does not exist.\n* Provided `training_data` or `test_data` does not have the fields requested in `enrichments.fields`.\n* Provided `training_data` or `test_data` does not have the field requested in `federated_classification.field`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Missing project.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: multipart/form-data\" \\\n",
                      "--form classifier=\"{\\\"name\\\": \\\"Customer comments classifier\\\", \\\n",
                      "  \\\"description\\\": \\\"User reviews\\\", \\\n",
                      "  \\\"language\\\": \\\"en\\\", \\\n",
                      "  \\\"answer_field\\\": \\\"label\\\", \\\n",
                      "  \\\"enrichments\\\": [ \\\n",
                      "    {\\\"enrichment_id\\\":\\\"701db916-fc83-57ab-0000-00000000001e\\\", \\\n",
                      "    \\\"fields\\\": [ \\\n",
                      "      \\\"text\\\", \\\"body\\\"] \\\n",
                      "    } \\\n",
                      "  ], \\\n",
                      "  \\\"federated_classification\\\": {\\\n",
                      "    \\\"field\\\": \\\"claim_product_line\\\" \\\n",
                      "  } \\\n",
                      "}\" \\\n",
                      "--form \"training_data=@training.csv;type=text/csv\" \\\n",
                      "--form \"test_data=@test.csv;type=text/csv\" \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/document_classifiers/{classifier_id}": {
      "get": {
        "operationId": "getDocumentClassifier",
        "summary": "Get a document classifier",
        "description": "Get details about a specific document classifier.",
        "tags": [
          "Document classifiers"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/classifierIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns details about a specific document classifier.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentClassifier"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Customer comments classifier",
                      "classifier_id": "0e36fdd2-7fb0-812b-0000-017ed29d6587",
                      "description": "User reviews",
                      "created": "2022-03-09T17:51:51.592Z",
                      "language": "en",
                      "enrichments": [
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-00000000001e",
                          "fields": [
                            "text",
                            "body"
                          ]
                        }
                      ],
                      "answer_field": "label",
                      "recognized_fields": [
                        "text",
                        "body",
                        "date",
                        "client_age",
                        "client_location",
                        "label",
                        "type_column",
                        "client_segment",
                        "claim_id",
                        "claim_product",
                        "claim_product_line"
                      ],
                      "training_data_file": "training.csv",
                      "test_data_file": "test.csv",
                      "federated_classification": {
                        "field": "claim_product_line"
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Document classifier or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers/{classifier_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "updateDocumentClassifier",
        "summary": "Update a document classifier",
        "description": "Update the document classifier name or description, update the training data, or add or update the test data.",
        "tags": [
          "Document classifiers"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/classifierIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/DocumentClassifierUpdate"
        },
        "responses": {
          "201": {
            "description": "Returns the updated document classifier details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentClassifier"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Customer feedback classifier",
                      "classifier_id": "0e36fdd2-7fb0-812b-0000-017ed29d6587",
                      "description": "User reviews and feedback",
                      "created": "2022-03-09T17:51:51.592Z",
                      "language": "en",
                      "enrichments": [
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-00000000001e",
                          "fields": [
                            "text",
                            "body"
                          ]
                        }
                      ],
                      "answer_field": "label",
                      "recognized_fields": [
                        "text",
                        "body",
                        "date",
                        "client_age",
                        "client_location",
                        "label",
                        "type_column",
                        "client_segment",
                        "claim_id",
                        "claim_product",
                        "claim_product_line"
                      ],
                      "training_data_file": "training.csv",
                      "test_data_file": "test.csv",
                      "federated_classification": {
                        "field": "claim_product_line"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request. A required parameter is null or invalid. Specific failure messages include:\n* No request body (missing classifier configuration).\n* Provided `training_data` or `test_data` does not have field requested in `answer_field`.\n* Provided `training_data` or `test_data` does not have the fields requested in `enrichments.fields`.\n* Provided `training_data` or `test_data` does not have the field requested in `federated_classification.field`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Missing project or classifier.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: multipart/form-data\" \\\n",
                      "--form classifier=\"{ \\\n",
                      "  \\\"name\\\": \\\"Customer feedback classifier\\\", \\\n",
                      "  \\\"description\\\": \\\"User reviews and feedback\\\" \\\n",
                      "  }\" \\\n",
                      "--form \"training_data=@training.csv;type=text/csv\" \\\n",
                      "--form \"test_data=@test.csv;type=text/csv\" \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers/{classifier_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteDocumentClassifier",
        "summary": "Delete a document classifier",
        "description": "Deletes an existing document classifier from the specified project.",
        "tags": [
          "Document classifiers"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/classifierIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "The document classifier was deleted successfully."
          },
          "400": {
            "description": "The document classifier cannot be deleted because the resulting classifier enrichment is applied to a collection. You must remove the enrichment from any collections that are using it before you attempt to delete the document classifier.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Missing project or classifier.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers/{classifier_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/document_classifiers/{classifier_id}/models": {
      "get": {
        "operationId": "listDocumentClassifierModels",
        "summary": "List document classifier models",
        "description": "Get a list of the document classifier models in a project. Returns only the name and model ID of each document classifier model.",
        "tags": [
          "Document classifier models"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/classifierIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns a list of document classifier models.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentClassifierModels"
                },
                "examples": {
                  "response": {
                    "value": {
                      "models": [
                        {
                          "name": "Model 1.0",
                          "model_id": "031f168e-0716-f6fe-0000-017f84d080e1"
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Document classifier or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers/{classifier_id}/models?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "createDocumentClassifierModel",
        "summary": "Create a document classifier model",
        "description": "Create a document classifier model by training a model that uses the data and classifier settings defined in the specified document classifier.\n\n**Note:** This method is supported on installed intances (IBM Cloud Pak for Data) or IBM Cloud-managed Premium or Enterprise plan instances.",
        "tags": [
          "Document classifier models"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/classifierIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/CreateDocumentClassifierModel"
        },
        "responses": {
          "201": {
            "description": "Returns the document classifier details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentClassifierModel"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Model 1.0",
                      "model_id": "47477591-b520-6039-0000-017e9d20e634",
                      "description": "First model",
                      "created": "2022-01-27T20:01:25.952Z",
                      "updated": "2022-01-27T20:01:26.094Z",
                      "status": "training"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request. A required parameter is null or invalid. Specific failure messages include:\n* No request body (discovery_missing_model_config).\n* Missing required request parameter or its value (classifier_missing_field_name).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Missing project or classifier.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"name\\\": \\\"Model 1.0\\\",  \\\n",
                      "  \\\"description\\\": \\\"First model\\\", \\\n",
                      "  \\\"learning_rate\\\": 0.1, \\\n",
                      "  \\\"l1_regularization_strengths\\\": [ \\\n",
                      "  0.000001 \\\n",
                      "  ], \\\n",
                      "  \\\"l2_regularization_strengths\\\": [ \\\n",
                      "  0.000001 \\\n",
                      "  ], \\\n",
                      "  \\\"training_max_steps\\\": 10000000, \\\n",
                      "  \\\"improvement_ratio\\\": 0.00001 \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers/{classifier_id}/models?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/document_classifiers/{classifier_id}/models/{model_id}": {
      "get": {
        "operationId": "getDocumentClassifierModel",
        "summary": "Get a document classifier model",
        "description": "Get details about a specific document classifier model.",
        "tags": [
          "Document classifier models"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/classifierIdParam"
          },
          {
            "$ref": "#/components/parameters/modelIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns details about a specific document classifier model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentClassifierModel"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Model 1.0",
                      "model_id": "47477591-b520-6039-0000-017e9d20e634",
                      "description": "First model",
                      "created": "2022-03-14T14:37:33.553Z",
                      "updated": "2022-03-14T14:40:41.634Z",
                      "training_data_file": "training.csv",
                      "test_data_file": "test.csv",
                      "status": "available",
                      "evaluation": {
                        "micro_average": {
                          "precision": 0.3484848439693451,
                          "recall": 0.7666666507720947,
                          "f1": 0.4791666567325592
                        },
                        "macro_average": {
                          "precision": 0.3279411792755127,
                          "recall": 0.5714285969734192,
                          "f1": 0.3811137080192566
                        },
                        "per_class": [
                          {
                            "precision": 0.5,
                            "recall": 1,
                            "f1": 0.6666666865348816,
                            "name": "expiration_date"
                          },
                          {
                            "precision": 0.25,
                            "recall": 0.5,
                            "f1": 0.3333333432674408,
                            "name": "ingredient.allergy"
                          },
                          {
                            "precision": 0.29411765933036804,
                            "recall": 1,
                            "f1": 0.4545454680919647,
                            "name": "amount.shortage"
                          },
                          {
                            "precision": 0.3529411852359772,
                            "recall": 1,
                            "f1": 0.52173912525177,
                            "name": "package_container"
                          },
                          {
                            "precision": 1,
                            "recall": 0.5,
                            "f1": 0.6666666865348816,
                            "name": "prank"
                          },
                          {
                            "precision": 0.4000000059604645,
                            "recall": 1,
                            "f1": 0.5714285969734192,
                            "name": "package_container.leak"
                          },
                          {
                            "precision": 0.5,
                            "recall": 1,
                            "f1": 0.6666666865348816,
                            "name": "change_of_properties"
                          },
                          {
                            "precision": 0,
                            "recall": 0,
                            "f1": 0,
                            "name": "contamination_tampering"
                          },
                          {
                            "precision": 1,
                            "recall": 1,
                            "f1": 1,
                            "name": "package_container.dirt"
                          },
                          {
                            "precision": 0.29411765933036804,
                            "recall": 1,
                            "f1": 0.4545454680919647,
                            "name": "other"
                          }
                        ]
                      },
                      "enrichment_id": "b9a35e7b-5073-1d0b-0000-017f89122c9d",
                      "deployed_at": "2022-03-14T14:40:40.572Z"
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Project or document classifier or document classifier model not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers/{classifier_id}/models/{model_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "updateDocumentClassifierModel",
        "summary": "Update a document classifier model",
        "description": "Update the document classifier model name or description.",
        "tags": [
          "Document classifier models"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/classifierIdParam"
          },
          {
            "$ref": "#/components/parameters/modelIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/DocumentClassifierModelUpdate"
        },
        "responses": {
          "201": {
            "description": "Returns the updated document classifier model details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentClassifierModel"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Renamed model",
                      "model_id": "47477591-b520-6039-0000-017e9d20e634",
                      "description": "Updated model",
                      "created": "2022-03-14T14:37:33.553Z",
                      "updated": "2022-03-14T20:59:58.685Z",
                      "training_data_file": "training.csv",
                      "test_data_file": "test.csv",
                      "status": "available",
                      "evaluation": {
                        "micro_average": {
                          "precision": 0.3484848439693451,
                          "recall": 0.7666666507720947,
                          "f1": 0.4791666567325592
                        },
                        "macro_average": {
                          "precision": 0.3279411792755127,
                          "recall": 0.5714285969734192,
                          "f1": 0.3811137080192566
                        },
                        "per_class": [
                          {
                            "precision": 0.5,
                            "recall": 1,
                            "f1": 0.6666666865348816,
                            "name": "expiration_date"
                          },
                          {
                            "precision": 0.25,
                            "recall": 0.5,
                            "f1": 0.3333333432674408,
                            "name": "ingredient.allergy"
                          },
                          {
                            "precision": 0.29411765933036804,
                            "recall": 1,
                            "f1": 0.4545454680919647,
                            "name": "amount.shortage"
                          },
                          {
                            "precision": 0.3529411852359772,
                            "recall": 1,
                            "f1": 0.52173912525177,
                            "name": "package_container"
                          },
                          {
                            "precision": 1,
                            "recall": 0.5,
                            "f1": 0.6666666865348816,
                            "name": "prank"
                          },
                          {
                            "precision": 0.4000000059604645,
                            "recall": 1,
                            "f1": 0.5714285969734192,
                            "name": "package_container.leak"
                          },
                          {
                            "precision": 0.5,
                            "recall": 1,
                            "f1": 0.6666666865348816,
                            "name": "change_of_properties"
                          },
                          {
                            "precision": 0,
                            "recall": 0,
                            "f1": 0,
                            "name": "contamination_tampering"
                          },
                          {
                            "precision": 1,
                            "recall": 1,
                            "f1": 1,
                            "name": "package_container.dirt"
                          },
                          {
                            "precision": 0.29411765933036804,
                            "recall": 1,
                            "f1": 0.4545454680919647,
                            "name": "other"
                          }
                        ]
                      },
                      "enrichment_id": "b9a35e7b-5073-1d0b-0000-017f89122c9d",
                      "deployed_at": "2022-03-14T14:40:40.572Z"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "No request body.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Project or document classifier or document classifier model not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"name\\\": \\\"Renamed model\\\",  \\\n",
                      "  \\\"description\\\": \\\"Updated model\\\" \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers/{classifier_id}/models/{model_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteDocumentClassifierModel",
        "summary": "Delete a document classifier model",
        "description": "Deletes an existing document classifier model from the specified project.",
        "tags": [
          "Document classifier models"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/classifierIdParam"
          },
          {
            "$ref": "#/components/parameters/modelIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "The document classifier model was deleted successfully."
          },
          "400": {
            "description": "The document classifier model cannot be deleted because the resulting classifier enrichment is applied to a collection. You must remove the enrichment from any collections that are using it before you attempt to delete the model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Project or document classifier or document classifier model not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/document_classifiers/{classifier_id}/models/{model_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}/analyze": {
      "post": {
        "operationId": "analyzeDocument",
        "summary": "Analyze a document",
        "description": "Process a document and return it for realtime use. Supports JSON files only.\n\nThe file is not stored in the collection, but is processed according to the collection's configuration settings. To get results, enrichments must be applied to a field in the collection that also exists in the file that you want to analyze. For example, to analyze text in a `Quote` field, you must apply enrichments to the `Quote` field in the collection configuration. Then, when you analyze the file, the text in the `Quote` field is analyzed and results are written to a field named `enriched_Quote`.\n\nSubmit a request against only one collection at a time. Remember, the documents in the collection are not significant. It is the enrichments that are defined for the collection that matter. If you submit requests to several collections, then several models are initiated at the same time, which can cause request failures.\n\n**Note:** This method is supported with Enterprise plan deployments and installed deployments only.",
        "tags": [
          "Analyze"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/AddDocument"
        },
        "responses": {
          "200": {
            "description": "The analyzed document.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnalyzedDocument"
                },
                "examples": {
                  "response": {
                    "value": {
                      "result": {
                        "enriched_Quote": [
                          {
                            "keywords": [
                              {
                                "text": "day",
                                "mentions": [
                                  {
                                    "text": "day",
                                    "location": {
                                      "begin": 10,
                                      "end": 13
                                    }
                                  }
                                ],
                                "relevance": 0.673739
                              },
                              {
                                "text": "stranger",
                                "mentions": [
                                  {
                                    "text": "stranger",
                                    "location": {
                                      "begin": 28,
                                      "end": 36
                                    }
                                  }
                                ],
                                "relevance": 0.596757
                              },
                              {
                                "text": "parents",
                                "mentions": [
                                  {
                                    "text": "parents",
                                    "location": {
                                      "begin": 52,
                                      "end": 59
                                    }
                                  }
                                ],
                                "relevance": 0.568336
                              },
                              {
                                "text": "mother",
                                "mentions": [
                                  {
                                    "text": "mother",
                                    "location": {
                                      "begin": 66,
                                      "end": 72
                                    }
                                  }
                                ],
                                "relevance": 0.755562
                              },
                              {
                                "text": "Mr. Collins",
                                "mentions": [
                                  {
                                    "text": "Mr. Collins",
                                    "location": {
                                      "begin": 118,
                                      "end": 129
                                    }
                                  }
                                ],
                                "relevance": 0.945891
                              }
                            ],
                            "entities": [
                              {
                                "text": "one",
                                "type": "Number",
                                "mentions": [
                                  {
                                    "text": "one",
                                    "confidence": 0.8,
                                    "location": {
                                      "begin": 40,
                                      "end": 43
                                    }
                                  }
                                ],
                                "model_name": "natural_language_understanding"
                              },
                              {
                                "text": "Mr. Collins",
                                "type": "Person",
                                "mentions": [
                                  {
                                    "text": "Mr. Collins",
                                    "confidence": 0.89255315,
                                    "location": {
                                      "begin": 118,
                                      "end": 129
                                    }
                                  }
                                ],
                                "model_name": "natural_language_understanding"
                              }
                            ]
                          }
                        ],
                        "url": "https://www.gutenberg.org/files/1342/1342-h/1342-h.htm#link2HCH0020",
                        "Subject": "Parental love",
                        "Year": "1813/01/01",
                        "Book": "Pride and Prejudice",
                        "Author": "Jane Austen",
                        "Quote": [
                          "From this day you must be a stranger to one of your parents. Your mother will never see you again if you do not marry Mr. Collins, and I will never see you again if you do."
                        ],
                        "metadata": {
                          "filename": "favorites2.json",
                          "file_type": "json"
                        },
                        "Speaker": "Mr. Bennett"
                      },
                      "notices": []
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Collection not supported for Analyze.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Project or collection not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "408": {
            "description": "Analyze timeout.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "413": {
            "description": "Document or metadata too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported media type.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Too many requests, try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: multipart/form-data\" \\\n",
                      "--form metadata=\"{\\\"filename\\\": \\\"favorites2.json\\\", \\\n",
                      "  \\\"file_type\\\": \\\"json\\\"}\" \\\n",
                      "--form \"file=@favorites2.json;type=application/json\" \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/analyze?version=2023-03-31\""
                    ]
                  },
                  {
                    "type": "markdown",
                    "source": [
                      "Download example document <a href=\"https://watson-developer-cloud.github.io/doc-tutorial-downloads/discovery/favorites2.json\" target=\"_blank\" download=\"favorites2.json\">favorites2.json</a>"
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/user_data": {
      "delete": {
        "tags": [
          "User data"
        ],
        "operationId": "deleteUserData",
        "summary": "Delete labeled data",
        "description": "Deletes all data associated with a specified customer ID. The method has no effect if no data is associated with the customer ID. \n\nYou associate a customer ID with data by passing the **X-Watson-Metadata** header with a request that passes data. For more information about personal data and customer IDs, see [Information security](/docs/discovery-data?topic=discovery-data-information-security#information-security). \n\n**Note:** This method is only supported on IBM Cloud instances of Discovery.",
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "name": "customer_id",
            "in": "query",
            "description": "The customer ID for which all data is to be deleted.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "**OK**. The delete request was successfully submitted."
          },
          "400": {
            "description": "**Bad Request**. The request did not pass a customer ID:\n* `No customer ID found in the request`",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/user_data?customer_id={id}&version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}": {
      "get": {
        "operationId": "getCollection",
        "summary": "Get collection details",
        "description": "Get details about the specified collection.",
        "tags": [
          "Collections"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the specified collection details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionDetails"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Tutorials",
                      "collection_id": "eb0215ed-6ec2-132a-0000-017b740f39c1",
                      "description": "Instructional PDFs",
                      "created": "2021-08-23T17:29:21.104Z",
                      "language": "en",
                      "enrichments": [
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000002",
                          "fields": [
                            "text"
                          ]
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-00000000001e",
                          "fields": [
                            "text"
                          ]
                        }
                      ],
                      "smart_document_understanding": {
                        "enabled": true,
                        "model": "text_extraction"
                      },
                      "source_document_counts": {
                        "pending": 0,
                        "processing": 0,
                        "available": 10,
                        "failed": 0
                      },
                      "document_counts": {
                        "processing": 0,
                        "available": 10,
                        "failed": 0
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Collection or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "updateCollection",
        "summary": "Update a collection",
        "description": "Updates the specified collection's name, description, enrichments, and configuration.\n\nIf you apply normalization rules to data in an existing collection, you must initiate reprocessing of the collection. To do so, from the *Manage fields* page in the product user interface, temporarily change the data type of a field to enable the reprocess button. Change the data type of the field back to its original value, and then click **Apply changes and reprocess**.\n\nTo remove a configuration that applies JSON normalization operations as part of the conversion phase of ingestion, specify an empty `json_normalizations` object (`[]`) in the request.\n\nTo remove a configuration that applies JSON normalization operations after enrichments are applied, specify an empty `normalizations` object (`[]`) in the request.",
        "tags": [
          "Collections"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/UpdateCollection"
        },
        "responses": {
          "200": {
            "description": "Returns the updated collection details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionDetails"
                },
                "examples": {
                  "response": {
                    "value": {
                      "name": "Tutorials for developers",
                      "collection_id": "eb0215ed-6ec2-132a-0000-017b740f39c1",
                      "description": "Instructional PDFs",
                      "created": "2021-08-23T17:29:21.104Z",
                      "language": "en",
                      "enrichments": [
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-000000000002",
                          "fields": [
                            "text"
                          ]
                        },
                        {
                          "enrichment_id": "701db916-fc83-57ab-0000-00000000001e",
                          "fields": [
                            "text"
                          ]
                        }
                      ],
                      "smart_document_understanding": {
                        "enabled": true,
                        "model": "text_extraction"
                      },
                      "source_document_counts": {
                        "pending": 0,
                        "processing": 0,
                        "available": 0,
                        "failed": 0
                      },
                      "document_counts": {
                        "processing": 0,
                        "available": 0,
                        "failed": 0
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request.\n\n- No request body.\n\n- Missing project or collection.\n\n- Invalid normalization operation is requested.\n\n- Missing normalization source.\n\n- Missing normalization destination.\n\n- Invalid normalization destination.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Collection or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"name\\\": \\\"Tutorials for developers\\\" \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "delete": {
        "operationId": "deleteCollection",
        "summary": "Delete a collection",
        "description": "Deletes the specified collection from the project. All documents stored in the specified collection and not shared is also deleted.",
        "tags": [
          "Collections"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "responses": {
          "204": {
            "description": "The collection has successfully been deleted."
          },
          "404": {
            "description": "Collection or project not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X DELETE {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}/batches": {
      "get": {
        "operationId": "listBatches",
        "summary": "List batches",
        "description": "A batch is a set of documents that are ready for enrichment by an external application. After you apply a webhook enrichment to a collection, and then process or upload documents to the collection, Discovery creates a batch with a unique **batch_id**.\n\n To start, you must register your external application as a **webhook** type by using the [Create enrichment API](/apidocs/discovery-data#createenrichment) method. \n\n**Note**: This method is available from IBM Cloud-managed instances only. The batches APIs are beta functionality. Beta features are not supported by the SDKs.\n\nUse the List batches API to get the following:\n\n * Notified batches that are not yet pulled by the external enrichment application.\n\n * Batches that are pulled, but not yet pushed to Discovery by the external enrichment application.",
        "tags": [
          "Batches"
        ],
        "x-ibm-release-level": "beta",
        "x-sdk-exclude": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns an array of available batches that are ready to be pulled by the external enrichment application.\n\nThe batches timeout automatically after around 72 hours from the time they were created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBatchesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Missing project or collection, or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/batches?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    },
    "/v2/projects/{project_id}/collections/{collection_id}/batches/{batch_id}": {
      "get": {
        "operationId": "pullBatches",
        "summary": "Pull batches",
        "description": "Pull a batch of documents from Discovery for enrichment by an external application. Ensure to include the `Accept-Encoding: gzip` header in this method to get the file. You can also implement retry logic when calling this method to avoid any network errors. \n\n**Note**: This method is available from IBM Cloud-managed instances only. The batches APIs are beta functionality. Beta features are not supported by the SDKs.",
        "tags": [
          "Batches"
        ],
        "x-ibm-release-level": "beta",
        "x-sdk-exclude": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          },
          {
            "$ref": "#/components/parameters/batchIdParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns a compressed NDJSON file.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pullBatchesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found. Returned when the project, collection, or batch is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl {auth} \\\n",
                      "--header \"Accept-Encoding: gzip\" \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/batches/{batch_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "post": {
        "operationId": "pushBatches",
        "summary": "Push batches",
        "description": "Push a batch of documents to Discovery after annotation by an external application. You can implement retry logic when calling this method to avoid any network errors. \n\n**Note**: This method is available from IBM Cloud-managed instances only. The batches APIs are beta functionality. Beta features are not supported by the SDKs.",
        "tags": [
          "Batches"
        ],
        "x-ibm-release-level": "beta",
        "x-sdk-exclude": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/versionParam"
          },
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/collectionIdParam"
          },
          {
            "$ref": "#/components/parameters/batchIdParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/AddBatch"
        },
        "responses": {
          "202": {
            "description": "The batch has been accepted and is being processed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchAccepted"
                }
              }
            }
          },
          "404": {
            "description": "Not found. Returned when the project, collection, or batch is missing. It is also returned when the batch is already processed or when a batch gets timed out.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "The batch is already pushed and accepted. Returned between the time the batch is submitted and the time when Discovery is processing the submitted documents.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--form \"file=@{filename}\"  \\\n",
                      "\"{url}/v2/projects/{project_id}/collections/{collection_id}/batches/{batch_id}?version=2023-03-31\""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    }
  },
  "servers": [
    {
      "url": "https://api.us-south.discovery.watson.cloud.ibm.com",
      "description": "Dallas"
    }
  ],
  "components": {
    "parameters": {
      "versionParam": {
        "name": "version",
        "in": "query",
        "description": "Release date of the version of the API you want to use. Specify dates in YYYY-MM-DD format. The current version is `2023-03-31`.",
        "required": true,
        "schema": {
          "type": "string"
        },
        "x-sdk-global-param": true
      },
      "projectIdParam": {
        "name": "project_id",
        "in": "path",
        "description": "The ID of the project. This information can be found from the *Integrate and Deploy* page in Discovery.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "collectionIdsParam": {
        "name": "collection_ids",
        "in": "query",
        "description": "Comma separated list of the collection IDs. If this parameter is not specified, all collections in the project are used.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "collectionIdParam": {
        "name": "collection_id",
        "in": "path",
        "description": "The ID of the collection.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "batchIdParam": {
        "name": "batch_id",
        "in": "path",
        "description": "The identifier of the document batch that is being requested from Discovery.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "documentIdParam": {
        "name": "document_id",
        "in": "path",
        "description": "The ID of the document.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "acFieldParam": {
        "name": "field",
        "in": "query",
        "description": "The field in the result documents that autocompletion suggestions are identified from.",
        "schema": {
          "type": "string"
        }
      },
      "acPrefixParam": {
        "name": "prefix",
        "in": "query",
        "description": "The prefix to use for autocompletion. For example, the prefix `Ho` could autocomplete to `hot`, `housing`, or `how`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "acCountParam": {
        "name": "count",
        "in": "query",
        "description": "The number of autocompletion suggestions to return.",
        "schema": {
          "type": "integer",
          "default": 5
        }
      },
      "forceParam": {
        "name": "X-Watson-Discovery-Force",
        "in": "header",
        "description": "When `true`, the uploaded document is added to the collection even if the data for that collection is shared with other collections.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "trainingQueryIdParam": {
        "name": "query_id",
        "in": "path",
        "description": "The ID of the query used for training.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "filterParam": {
        "name": "filter",
        "in": "query",
        "description": "Searches for documents that match the Discovery Query Language criteria that is specified as input. Filter calls are cached and are faster than query calls because the results are not ordered by relevance. When used with the `aggregation`, `query`, or `natural_language_query` parameters, the `filter` parameter runs first. This parameter is useful for limiting results to those that contain specific metadata values.",
        "schema": {
          "type": "string"
        }
      },
      "queryParam": {
        "name": "query",
        "in": "query",
        "description": "A query search that is written in the Discovery Query Language and returns all matching documents in your data set with full enrichments and full text, and with the most relevant documents listed first. You can use this parameter or the **natural_language_query** parameter to specify the query input, but not both.",
        "schema": {
          "type": "string"
        }
      },
      "nlqParam": {
        "name": "natural_language_query",
        "in": "query",
        "description": "A natural language query that returns relevant documents by using natural language understanding. You can use this parameter or the **query** parameter to specify the query input, but not both. To filter the results based on criteria you specify, include the **filter** parameter in the request.",
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 2048
        }
      },
      "countParam": {
        "name": "count",
        "in": "query",
        "description": "Number of results to return. The maximum for the **count** and **offset** values together in any one query is **10,000**",
        "schema": {
          "type": "integer",
          "default": 10
        }
      },
      "offsetParam": {
        "name": "offset",
        "in": "query",
        "description": "The number of query results to skip at the beginning. For example, if the total number of results that are returned is 10 and the offset is 8, it returns the last two results. The maximum for the **count** and **offset** values together in any one query is **10000**",
        "schema": {
          "type": "integer"
        }
      },
      "curationIdParam": {
        "name": "curation_id",
        "in": "path",
        "description": "The ID of the curation.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "enrichmentIdParam": {
        "name": "enrichment_id",
        "in": "path",
        "description": "The ID of the enrichment.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "classifierIdParam": {
        "name": "classifier_id",
        "in": "path",
        "description": "The ID of the classifier.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "modelIdParam": {
        "name": "model_id",
        "in": "path",
        "description": "The ID of the classifier model.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "docCountParam": {
        "name": "count",
        "in": "query",
        "description": "The maximum number of documents to return. Up to 1,000 documents are returned by default. The maximum number allowed is 10,000.",
        "schema": {
          "type": "integer",
          "default": 1000
        }
      },
      "docStatusParam": {
        "name": "status",
        "in": "query",
        "description": "Filters the documents to include only documents with the specified ingestion status. The options include:\n\n* `available`: Ingestion is finished and the document is indexed.\n\n* `failed`: Ingestion is finished, but the document is not indexed because of an error.\n\n* `pending`: The document is uploaded, but the ingestion process is not started.\n\n* `processing`: Ingestion is in progress.\n\nYou can specify one status value or add a comma-separated list of more than one status value. For example, `available,failed`.",
        "schema": {
          "type": "string"
        }
      },
      "docHasNoticesParam": {
        "name": "has_notices",
        "in": "query",
        "description": "If set to `true`, only documents that have notices, meaning documents for which warnings or errors were generated during the ingestion, are returned. If set to `false`, only documents that don't have notices are returned. If unspecified, no filter based on notices is applied.\n\nNotice details are not available in the result, but you can use the [Query collection notices](#querycollectionnotices) method to find details by adding the parameter `query=notices.document_id:{document-id}`.",
        "schema": {
          "type": "boolean"
        }
      },
      "docIsParentParam": {
        "name": "is_parent",
        "in": "query",
        "description": "If set to `true`, only parent documents, meaning documents that were split during the ingestion process and resulted in two or more child documents, are returned. If set to `false`, only child documents are returned. If unspecified, no filter based on the parent or child relationship is applied.\n\nCSV files, for example, are split into separate documents per line and JSON files are split into separate documents per object.",
        "schema": {
          "type": "boolean"
        }
      },
      "docParentDocIDParam": {
        "name": "parent_document_id",
        "in": "query",
        "description": "Filters the documents to include only child documents that were generated when the specified parent document was processed.",
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "docSha256Param": {
        "name": "sha256",
        "in": "query",
        "description": "Filters the documents to include only documents with the specified SHA-256 hash. Format the hash as a hexadecimal string.",
        "schema": {
          "type": "string"
        }
      }
    },
    "requestBodies": {
      "QueryLarge": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/QueryLarge"
            }
          }
        },
        "description": "An object that represents the query to be submitted."
      },
      "AddDocument": {
        "content": {
          "multipart/form-data": {
            "schema": {
              "type": "object",
              "properties": {
                "file": {
                  "description": "**Add a document**: The content of the document to ingest. For the supported file types and maximum supported file size limits when adding a document, see [the documentation](/docs/discovery-data?topic=discovery-data-collections#supportedfiletypes).\n\n**Analyze a document**: The content of the document to analyze but not ingest. Only the `application/json` content type is supported by the Analyze API. For maximum supported file size limits, see [the product documentation](/docs/discovery-data?topic=discovery-data-analyzeapi#analyzeapi-limits).",
                  "type": "string",
                  "format": "binary",
                  "x-file-content-types": [
                    "application/json",
                    "application/msword",
                    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    "application/pdf",
                    "text/html",
                    "application/xhtml+xml"
                  ],
                  "x-include-filename": true
                },
                "metadata": {
                  "description": "Add information about the file that you want to include in the response.\n\nThe maximum supported metadata file size is 1 MB. Metadata parts larger than 1 MB are rejected.\n\nExample:\n\n ``` \n { \n  \"filename\": \"favorites2.json\",\n  \"file_type\": \"json\"\n }",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "AddTrainingQuery": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/TrainingQuery"
            }
          }
        },
        "description": "An object that represents the query to be submitted. At least 50 queries are required for training to begin. A maximum of 10,000 queries are allowed.",
        "required": true
      },
      "CreateCollection": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/CollectionDetails"
            }
          }
        },
        "description": "An object that represents the collection to be created.",
        "required": true
      },
      "CreateProject": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ProjectCreation"
            }
          }
        },
        "description": "An object that represents the project to be created.",
        "required": true
      },
      "ProjectName": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ProjectName"
            }
          }
        },
        "description": "An object that represents the new name of the project."
      },
      "EnrichmentDetails": {
        "content": {
          "multipart/form-data": {
            "schema": {
              "required": [
                "enrichment"
              ],
              "type": "object",
              "properties": {
                "file": {
                  "description": "The enrichment file to upload. Expected file types per enrichment are as follows:\n\n* CSV for `dictionary` and `sentence_classifier` (the training data CSV file to upload).\n\n* PEAR for `uima_annotator` and `rule_based` (Explorer)\n\n* ZIP for `watson_knowledge_studio_model` and `rule_based` (Studio Advanced Rule Editor)",
                  "type": "string",
                  "format": "binary",
                  "x-file-content-types": [
                    "application/octet-stream"
                  ]
                },
                "enrichment": {
                  "$ref": "#/components/schemas/CreateEnrichment"
                }
              }
            }
          }
        },
        "required": true
      },
      "EnrichmentUpdate": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/UpdateEnrichment"
            }
          }
        },
        "required": true,
        "description": "An object that lists the new name and description for an enrichment."
      },
      "UpdateCollection": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/UpdateCollection"
            }
          }
        },
        "description": "An object that represents the collection to be updated.",
        "required": true
      },
      "DocumentClassifierCreate": {
        "content": {
          "multipart/form-data": {
            "schema": {
              "required": [
                "classifier",
                "training_data"
              ],
              "type": "object",
              "properties": {
                "training_data": {
                  "description": "The training data CSV file to upload. The CSV file must have headers. The file must include a field that contains the text you want to classify and a field that contains the classification labels that you want to use to classify your data. If you want to specify multiple values in a single field, use a semicolon as the value separator. For a sample file, see [the product documentation](/docs/discovery-data?topic=discovery-data-cm-doc-classifier).",
                  "type": "string",
                  "format": "binary",
                  "x-file-content-types": [
                    "text/csv"
                  ]
                },
                "test_data": {
                  "description": "The CSV with test data to upload. The column values in the test file must be the same as the column values in the training data file. If no test data is provided, the training data is split into two separate groups of training and test data.",
                  "type": "string",
                  "format": "binary",
                  "x-file-content-types": [
                    "text/csv"
                  ]
                },
                "classifier": {
                  "$ref": "#/components/schemas/CreateDocumentClassifier"
                }
              }
            }
          }
        },
        "required": true
      },
      "DocumentClassifierUpdate": {
        "content": {
          "multipart/form-data": {
            "schema": {
              "required": [
                "classifier"
              ],
              "type": "object",
              "properties": {
                "training_data": {
                  "description": "The training data CSV file to upload. The CSV file must have headers. The file must include a field that contains the text you want to classify and a field that contains the classification labels that you want to use to classify your data. If you want to specify multiple values in a single column, use a semicolon as the value separator. For a sample file, see [the product documentation](/docs/discovery-data?topic=discovery-data-cm-doc-classifier).",
                  "type": "string",
                  "format": "binary",
                  "x-file-content-types": [
                    "text/csv"
                  ]
                },
                "test_data": {
                  "description": "The CSV with test data to upload. The column values in the test file must be the same as the column values in the training data file. If no test data is provided, the training data is split into two separate groups of training and test data.",
                  "type": "string",
                  "format": "binary",
                  "x-file-content-types": [
                    "text/csv"
                  ]
                },
                "classifier": {
                  "$ref": "#/components/schemas/UpdateDocumentClassifier"
                }
              }
            }
          }
        },
        "required": true
      },
      "CreateDocumentClassifierModel": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentClassifierModelTrain"
            }
          }
        },
        "description": "An object that contains the training configuration information for the document classifier to be trained.",
        "required": true
      },
      "DocumentClassifierModelUpdate": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/UpdateDocumentClassifierModel"
            }
          }
        },
        "required": true,
        "description": "An object that lists a new name or description for a document classifier model."
      },
      "AddBatch": {
        "content": {
          "multipart/form-data": {
            "schema": {
              "type": "object",
              "properties": {
                "file": {
                  "description": "A compressed newline-delimited JSON (NDJSON), which is a JSON file with one row of data per line. For example, `{batch_id}.ndjson.gz`. For more information, see [Binary attachment in the push batches method](/docs/discovery-data?topic=discovery-data-external-enrichment#binary-attachment-push-batches).\n\nThere is no limitation on the name of the file because Discovery does not use the name for processing. The list of features in the document is specified in the `features` object.",
                  "type": "string",
                  "format": "binary",
                  "x-file-content-types": [],
                  "x-include-filename": true
                }
              }
            }
          }
        }
      }
    },
    "securitySchemes": {
      "IAM": {
        "type": "apiKey",
        "name": "Authorization",
        "description": "For services managed on IBM Cloud, you authenticate to the API by using IBM Cloud Identity and Access Management (IAM). You can pass either a bearer token in an authorization header or an API key.",
        "in": "header"
      }
    },
    "schemas": {
      "ListCollectionsResponse": {
        "description": "Response object that contains an array of collection details.",
        "type": "object",
        "properties": {
          "collections": {
            "type": "array",
            "description": "An array that contains information about each collection in the project.",
            "items": {
              "$ref": "#/components/schemas/Collection"
            }
          }
        },
        "example": {
          "collections": [
            {
              "collection_id": "f1360220-ea2d-4271-9d62-89a910b13c37",
              "name": "example"
            }
          ]
        }
      },
      "ListDocumentsResponse": {
        "description": "Response object that contains an array of documents.",
        "type": "object",
        "properties": {
          "matching_results": {
            "description": "The number of matching results for the document query.",
            "type": "integer",
            "format": "int32"
          },
          "documents": {
            "type": "array",
            "description": "An array that lists the documents in a collection. Only the document ID of each document is returned in the list. You can use the [Get document](#getdocument) method to get more information about an individual document.",
            "items": {
              "$ref": "#/components/schemas/DocumentDetails"
            }
          }
        },
        "example": {
          "matching_results": 2,
          "documents": [
            {
              "document_id": "4ffcfd8052005b99469e632506763bac_0"
            },
            {
              "document_id": "4ffcfd8052005b99469e632506763bac_1"
            }
          ]
        }
      },
      "TableElementLocation": {
        "type": "object",
        "required": [
          "begin",
          "end"
        ],
        "description": "The numeric location of the identified element in the document, represented with two integers labeled `begin` and `end`.",
        "properties": {
          "begin": {
            "description": "The element's `begin` index.",
            "type": "integer",
            "format": "int64"
          },
          "end": {
            "description": "The element's `end` index.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "QueryResponse": {
        "type": "object",
        "description": "A response that contains the documents and aggregations for the query.",
        "properties": {
          "matching_results": {
            "description": "The number of matching results for the query. Results that match due to a curation only are not counted in the total.",
            "type": "integer",
            "format": "int32"
          },
          "results": {
            "description": "Array of document results for the query.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryResult"
            }
          },
          "aggregations": {
            "description": "Array of aggregations for the query.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryAggregation"
            },
            "minItems": 1,
            "maxItems": 50000
          },
          "retrieval_details": {
            "$ref": "#/components/schemas/RetrievalDetails"
          },
          "suggested_query": {
            "type": "string",
            "description": "Suggested correction to the submitted **natural_language_query** value."
          },
          "suggested_refinements": {
            "description": "Array of suggested refinements. **Note**: The `suggested_refinements` parameter that identified dynamic facets from the data is deprecated.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuerySuggestedRefinement"
            },
            "deprecated": true
          },
          "table_results": {
            "description": "Array of table results.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryTableResult"
            }
          },
          "passages": {
            "type": "array",
            "description": "Passages that best match the query from across all of the collections in the project. Returned if **passages.per_document** is `false`.",
            "items": {
              "$ref": "#/components/schemas/QueryResponsePassage"
            }
          }
        },
        "example": {
          "matching_results": 24,
          "retrieval_details": {
            "document_retrieval_strategy": "untrained"
          },
          "results": [
            {
              "id": "watson-generated ID"
            }
          ],
          "aggregations": [
            {
              "type": "term",
              "field": "field",
              "count": 1,
              "results": [
                {
                  "key": "active",
                  "matching_results": 34
                }
              ]
            }
          ]
        }
      },
      "QueryResult": {
        "type": "object",
        "description": "Result document for the specified query.",
        "required": [
          "document_id",
          "result_metadata"
        ],
        "properties": {
          "document_id": {
            "type": "string",
            "description": "The unique identifier of the document."
          },
          "metadata": {
            "type": "object",
            "description": "Metadata of the document.",
            "additionalProperties": true
          },
          "result_metadata": {
            "$ref": "#/components/schemas/QueryResultMetadata"
          },
          "document_passages": {
            "type": "array",
            "description": "Passages from the document that best matches the query. Returned if **passages.per_document** is `true`.",
            "items": {
              "$ref": "#/components/schemas/QueryResultPassage"
            }
          }
        },
        "additionalProperties": {
          "type": "object",
          "description": "The remaining key-value pairs"
        }
      },
      "QueryResultMetadata": {
        "type": "object",
        "description": "Metadata of a query result.",
        "required": [
          "collection_id"
        ],
        "properties": {
          "document_retrieval_source": {
            "type": "string",
            "enum": [
              "search",
              "curation"
            ],
            "description": "The document retrieval source that produced this search result."
          },
          "collection_id": {
            "type": "string",
            "description": "The collection id associated with this training data set."
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "description": "The confidence score for the given result. Calculated based on how relevant the result is estimated to be. The score can range from `0.0` to `1.0`. The higher the number, the more relevant the document. The `confidence` value for a result was calculated using the model specified in the `document_retrieval_strategy` field of the result set. This field is returned only if the **natural_language_query** parameter is specified in the query.",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "QueryResultPassage": {
        "description": "A passage query result.",
        "type": "object",
        "properties": {
          "passage_text": {
            "type": "string",
            "description": "The content of the extracted passage."
          },
          "start_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position of the first character of the extracted passage in the originating field."
          },
          "end_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position after the last character of the extracted passage in the originating field."
          },
          "field": {
            "type": "string",
            "description": "The label of the field from which the passage has been extracted."
          },
          "answers": {
            "type": "array",
            "description": "An arry of extracted answers to the specified query. Returned for natural language queries when **passages.per_document** is `true`.",
            "items": {
              "$ref": "#/components/schemas/ResultPassageAnswer"
            }
          }
        }
      },
      "QueryResponsePassage": {
        "description": "A passage query response.",
        "type": "object",
        "properties": {
          "passage_text": {
            "type": "string",
            "description": "The content of the extracted passage."
          },
          "passage_score": {
            "type": "number",
            "format": "double",
            "description": "The confidence score of the passage's analysis. A higher score indicates greater confidence. The score is used to rank the passages from all documents and is returned only if **passages.per_document** is `false`."
          },
          "document_id": {
            "type": "string",
            "description": "The unique identifier of the ingested document."
          },
          "collection_id": {
            "type": "string",
            "description": "The unique identifier of the collection."
          },
          "start_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position of the first character of the extracted passage in the originating field."
          },
          "end_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position after the last character of the extracted passage in the originating field."
          },
          "field": {
            "type": "string",
            "description": "The label of the field from which the passage has been extracted."
          },
          "answers": {
            "type": "array",
            "description": "An array of extracted answers to the specified query. Returned for natural language queries when **passages.per_document** is `false`.",
            "items": {
              "$ref": "#/components/schemas/ResultPassageAnswer"
            }
          }
        }
      },
      "QueryTableResult": {
        "type": "object",
        "description": "A tables whose content or context match a search query.",
        "properties": {
          "table_id": {
            "type": "string",
            "description": "The identifier for the retrieved table."
          },
          "source_document_id": {
            "type": "string",
            "description": "The identifier of the document the table was retrieved from."
          },
          "collection_id": {
            "type": "string",
            "description": "The identifier of the collection the table was retrieved from."
          },
          "table_html": {
            "type": "string",
            "description": "HTML snippet of the table info."
          },
          "table_html_offset": {
            "type": "integer",
            "description": "The offset of the table html snippet in the original document html."
          },
          "table": {
            "$ref": "#/components/schemas/TableResultTable"
          }
        }
      },
      "QuerySuggestedRefinement": {
        "type": "object",
        "description": "A suggested additional query term or terms user to filter results. **Note**: The `suggested_refinements` parameter is deprecated.",
        "properties": {
          "text": {
            "type": "string",
            "description": "The text used to filter."
          }
        },
        "deprecated": true
      },
      "QueryAggregation": {
        "type": "object",
        "description": "An object that defines how to aggregate query results.",
        "anyOf": [
          {
            "$ref": "#/components/schemas/QueryTermAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryGroupByAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryHistogramAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryTimesliceAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryNestedAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryFilterAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryCalculationAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryTopHitsAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryPairAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryTrendAggregation"
          },
          {
            "$ref": "#/components/schemas/QueryTopicAggregation"
          }
        ],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "term": "#/components/schemas/QueryTermAggregation",
            "group_by": "#/components/schemas/QueryGroupByAggregation",
            "histogram": "#/components/schemas/QueryHistogramAggregation",
            "timeslice": "#/components/schemas/QueryTimesliceAggregation",
            "nested": "#/components/schemas/QueryNestedAggregation",
            "filter": "#/components/schemas/QueryFilterAggregation",
            "min": "#/components/schemas/QueryCalculationAggregation",
            "max": "#/components/schemas/QueryCalculationAggregation",
            "sum": "#/components/schemas/QueryCalculationAggregation",
            "average": "#/components/schemas/QueryCalculationAggregation",
            "unique_count": "#/components/schemas/QueryCalculationAggregation",
            "top_hits": "#/components/schemas/QueryTopHitsAggregation",
            "pair": "#/components/schemas/QueryPairAggregation",
            "trend": "#/components/schemas/QueryTrendAggregation",
            "topic": "#/components/schemas/QueryTopicAggregation"
          }
        }
      },
      "QuerySubAggregation": {
        "type": "object",
        "description": "Aggregation results. For more information about supported aggregation types, see the [product documentation](/docs/discovery-data?topic=discovery-data-query-aggregations).",
        "additionalProperties": true
      },
      "QueryTermAggregation": {
        "type": "object",
        "description": "Returns results from the field that is specified.",
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `term`."
          },
          "field": {
            "type": "string",
            "description": "The field in the document where the values come from."
          },
          "count": {
            "type": "integer",
            "format": "int32",
            "description": "The number of results returned. Not returned if `relevancy:true` is specified in the request."
          },
          "name": {
            "type": "string",
            "description": "Identifier specified in the query request of this aggregation. Not returned if `relevancy:true` is specified in the request."
          },
          "results": {
            "type": "array",
            "description": "An array of results.",
            "items": {
              "$ref": "#/components/schemas/QueryTermAggregationResult"
            },
            "x-apex-alternate-name": "term_results"
          }
        }
      },
      "QueryTermAggregationResult": {
        "type": "object",
        "description": "Top value result for the `term` aggregation.",
        "required": [
          "key",
          "matching_results"
        ],
        "properties": {
          "key": {
            "type": "string",
            "description": "Value of the field with a nonzero frequency in the document set."
          },
          "matching_results": {
            "type": "integer",
            "format": "int32",
            "description": "Number of documents that contain the 'key'."
          },
          "relevancy": {
            "type": "number",
            "format": "double",
            "description": "The relevancy score for this result. Returned only if `relevancy:true` is specified in the request."
          },
          "total_matching_documents": {
            "type": "integer",
            "format": "int32",
            "description": "Number of documents in the collection that contain the term in the specified field. Returned only when `relevancy:true` is specified in the request."
          },
          "estimated_matching_results": {
            "type": "number",
            "format": "double",
            "description": "Number of documents that are estimated to match the query and also meet the condition. Returned only when `relevancy:true` is specified in the request."
          },
          "aggregations": {
            "type": "array",
            "description": "An array of subaggregations. Returned only when this aggregation is combined with other aggregations in the request or is returned as a subaggregation.",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "QueryGroupByAggregation": {
        "type": "object",
        "description": "Separates document results into groups that meet the conditions you specify.",
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `group_by`."
          },
          "results": {
            "type": "array",
            "description": "An array of results.",
            "items": {
              "$ref": "#/components/schemas/QueryGroupByAggregationResult"
            },
            "x-apex-alternate-name": "group_by_results"
          }
        }
      },
      "QueryGroupByAggregationResult": {
        "type": "object",
        "description": "Result group for the `group_by` aggregation.",
        "required": [
          "key",
          "matching_results"
        ],
        "properties": {
          "key": {
            "type": "string",
            "description": "The condition that is met by the documents in this group. For example, `YEARTXT<2000`."
          },
          "matching_results": {
            "type": "integer",
            "format": "int32",
            "description": "Number of documents that meet the query and condition."
          },
          "relevancy": {
            "type": "number",
            "format": "double",
            "description": "The relevancy for this group. Returned only if `relevancy:true` is specified in the request."
          },
          "total_matching_documents": {
            "type": "integer",
            "format": "int32",
            "description": "Number of documents that meet the condition in the whole set of documents in this collection. Returned only when `relevancy:true` is specified in the request."
          },
          "estimated_matching_results": {
            "type": "number",
            "format": "double",
            "description": "The number of documents that are estimated to match the query and condition. Returned only when `relevancy:true` is specified in the request."
          },
          "aggregations": {
            "type": "array",
            "description": "An array of subaggregations. Returned only when this aggregation is returned as a subaggregation.",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "QueryHistogramAggregation": {
        "type": "object",
        "description": "Numeric interval segments to categorize documents by using field values from a single numeric field to describe the category.",
        "required": [
          "field",
          "interval"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `histogram`."
          },
          "field": {
            "type": "string",
            "description": "The numeric field name used to create the histogram."
          },
          "interval": {
            "type": "integer",
            "format": "int32",
            "description": "The size of the sections that the results are split into.",
            "x-apex-alternate-name": "histogram_interval"
          },
          "name": {
            "type": "string",
            "description": "Identifier that can optionally be specified in the query request of this aggregation."
          },
          "results": {
            "type": "array",
            "description": "Array of numeric intervals",
            "items": {
              "$ref": "#/components/schemas/QueryHistogramAggregationResult"
            },
            "x-apex-alternate-name": "histogram_results"
          }
        }
      },
      "QueryHistogramAggregationResult": {
        "type": "object",
        "description": "Histogram numeric interval result.",
        "required": [
          "key",
          "matching_results"
        ],
        "properties": {
          "key": {
            "type": "integer",
            "format": "int64",
            "description": "The value of the upper bound for the numeric segment."
          },
          "matching_results": {
            "type": "integer",
            "format": "int32",
            "description": "Number of documents with the specified key as the upper bound."
          },
          "aggregations": {
            "type": "array",
            "description": "An array of subaggregations. Returned only when this aggregation is returned as a subaggregation.",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "QueryTimesliceAggregation": {
        "type": "object",
        "description": "A specialized histogram aggregation that uses dates to create interval segments.",
        "required": [
          "field",
          "interval"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `timeslice`."
          },
          "field": {
            "type": "string",
            "description": "The date field name used to create the timeslice."
          },
          "interval": {
            "type": "string",
            "description": "The date interval value. Valid values are seconds, minutes, hours, days, weeks, and years.",
            "x-apex-alternate-name": "timeslice_interval"
          },
          "name": {
            "type": "string",
            "description": "Identifier that can optionally be specified in the query request of this aggregation."
          },
          "results": {
            "description": "Array of aggregation results",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryTimesliceAggregationResult"
            },
            "x-apex-alternate-name": "timeslice_results"
          }
        }
      },
      "QueryTimesliceAggregationResult": {
        "type": "object",
        "description": "A timeslice interval segment.",
        "required": [
          "key_as_string",
          "key",
          "matching_results"
        ],
        "properties": {
          "key_as_string": {
            "type": "string",
            "description": "String date value of the upper bound for the timeslice interval in ISO-8601 format."
          },
          "key": {
            "type": "integer",
            "format": "int64",
            "description": "Numeric date value of the upper bound for the timeslice interval in UNIX milliseconds since epoch."
          },
          "matching_results": {
            "type": "integer",
            "format": "int64",
            "description": "Number of documents with the specified key as the upper bound."
          },
          "aggregations": {
            "type": "array",
            "description": "An array of subaggregations. Returned only when this aggregation is returned as a subaggregation.",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "QueryNestedAggregation": {
        "type": "object",
        "description": "A restriction that alters the document set that is used by the aggregations that it precedes. Subsequent aggregations are applied to nested documents from the specified field.",
        "required": [
          "path",
          "matching_results"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `nested`."
          },
          "path": {
            "type": "string",
            "description": "The path to the document field to scope subsequent aggregations to."
          },
          "matching_results": {
            "type": "integer",
            "format": "int64",
            "description": "Number of nested documents found in the specified field."
          },
          "aggregations": {
            "type": "array",
            "description": "An array of subaggregations.",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "QueryFilterAggregation": {
        "type": "object",
        "description": "A modifier that narrows the document set of the subaggregations it precedes.",
        "required": [
          "match",
          "matching_results"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `filter`."
          },
          "match": {
            "type": "string",
            "description": "The filter that is written in Discovery Query Language syntax and is applied to the documents before subaggregations are run."
          },
          "matching_results": {
            "type": "integer",
            "format": "int64",
            "description": "Number of documents that match the filter."
          },
          "aggregations": {
            "type": "array",
            "description": "An array of subaggregations.",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "QueryCalculationAggregation": {
        "type": "object",
        "description": "Returns a scalar calculation across all documents for the field specified. Possible calculations include min, max, sum, average, and unique_count.",
        "required": [
          "field"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies the calculation type, such as 'average`, `max`, `min`, `sum`, or `unique_count`."
          },
          "field": {
            "type": "string",
            "description": "The field to perform the calculation on."
          },
          "value": {
            "description": "The value of the calculation.",
            "type": "number",
            "format": "double"
          }
        }
      },
      "QueryTopHitsAggregation": {
        "type": "object",
        "description": "Returns the top documents ranked by the score of the query.",
        "required": [
          "size"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `top_hits`."
          },
          "size": {
            "type": "integer",
            "format": "int32",
            "description": "The number of documents to return."
          },
          "name": {
            "type": "string",
            "description": "Identifier specified in the query request of this aggregation."
          },
          "hits": {
            "$ref": "#/components/schemas/QueryTopHitsAggregationResult"
          }
        }
      },
      "QueryTopHitsAggregationResult": {
        "type": "object",
        "description": "A query response that contains the matching documents for the preceding aggregations.",
        "required": [
          "matching_results"
        ],
        "properties": {
          "matching_results": {
            "type": "integer",
            "format": "int32",
            "description": "Number of matching results."
          },
          "hits": {
            "type": "array",
            "description": "An array of the document results in an ordered list.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          }
        }
      },
      "QueryPairAggregation": {
        "type": "object",
        "description": "Calculates relevancy values using combinations of document sets from results of the specified pair of aggregations.",
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `pair`."
          },
          "first": {
            "type": "string",
            "description": "Specifies the first aggregation in the pair. The aggregation must be a `term`, `group_by`, `histogram`, or `timeslice` aggregation type."
          },
          "second": {
            "type": "string",
            "description": "Specifies the second aggregation in the pair. The aggregation must be a `term`, `group_by`, `histogram`, or `timeslice` aggregation type."
          },
          "show_estimated_matching_results": {
            "type": "boolean",
            "default": false,
            "description": "Indicates whether to include estimated matching result information."
          },
          "show_total_matching_documents": {
            "type": "boolean",
            "default": false,
            "description": "Indicates whether to include total matching documents information."
          },
          "results": {
            "type": "array",
            "description": "An array of aggregations.",
            "items": {
              "$ref": "#/components/schemas/QueryPairAggregationResult"
            },
            "x-apex-alternate-name": "pair_results"
          }
        }
      },
      "QueryPairAggregationResult": {
        "type": "object",
        "description": "Result for the `pair` aggregation.",
        "properties": {
          "aggregations": {
            "description": "Array of subaggregations of type `term`, `group_by`, `histogram`, or `timeslice`. Each element of the matrix that is returned contains a **relevancy** value that is calculated from the combination of each value from the first and second aggregations.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "QueryTrendAggregation": {
        "type": "object",
        "description": "Detects sharp and unexpected changes in the frequency of a facet or facet value over time based on the past history of frequency changes of the facet value.",
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `trend`."
          },
          "facet": {
            "type": "string",
            "description": "Specifies the `term` or `group_by` aggregation for the facet that you want to analyze."
          },
          "time_segments": {
            "type": "string",
            "description": "Specifies the `timeslice` aggregation that defines the time segments."
          },
          "show_estimated_matching_results": {
            "type": "boolean",
            "default": false,
            "description": "Indicates whether to include estimated matching result information."
          },
          "show_total_matching_documents": {
            "type": "boolean",
            "default": false,
            "description": "Indicates whether to include total matching documents information."
          },
          "results": {
            "type": "array",
            "description": "An array of aggregations.",
            "items": {
              "$ref": "#/components/schemas/QueryTrendAggregationResult"
            },
            "x-apex-alternate-name": "trend_results"
          }
        }
      },
      "QueryTrendAggregationResult": {
        "type": "object",
        "description": "Result for the `trend` aggregation.",
        "properties": {
          "aggregations": {
            "description": "Array of subaggregations of type `term` or `group_by` and `timeslice`. Each element of the matrix that is returned contains a **trend_indicator** that is calculated from the combination of each aggregation value and segment of time.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "QueryTopicAggregation": {
        "type": "object",
        "description": "Detects how much the frequency of a given facet value deviates from the expected average for the given time period. This aggregation type does not use data from previous time periods. It calculates an index by using the averages of frequency counts of other facet values for the given time period.",
        "properties": {
          "type": {
            "type": "string",
            "description": "Specifies that the aggregation type is `topic`."
          },
          "facet": {
            "type": "string",
            "description": "Specifies the `term` or `group_by` aggregation for the facet that you want to analyze."
          },
          "time_segments": {
            "type": "string",
            "description": "Specifies the `timeslice` aggregation that defines the time segments."
          },
          "show_estimated_matching_results": {
            "type": "boolean",
            "default": false,
            "description": "Indicates whether to include estimated matching result information."
          },
          "show_total_matching_documents": {
            "type": "boolean",
            "default": false,
            "description": "Indicates whether to include total matching documents information."
          },
          "results": {
            "type": "array",
            "description": "An array of aggregations.",
            "items": {
              "$ref": "#/components/schemas/QueryTopicAggregationResult"
            },
            "x-apex-alternate-name": "topic_results"
          }
        }
      },
      "QueryTopicAggregationResult": {
        "type": "object",
        "description": "Result for the `topic` aggregation.",
        "properties": {
          "aggregations": {
            "description": "Array of subaggregations  of type `term` or `group_by` and `timeslice`. Each element of the matrix that is returned contains a **topic_indicator** that is calculated from the combination of each aggregation value and segment of time.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuerySubAggregation"
            }
          }
        }
      },
      "TableHeaders": {
        "type": "object",
        "description": "The contents of the current table's header.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the cell in the current table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The textual contents of the cell from the input document without associated markup content."
          },
          "row_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `row` location in the current table."
          },
          "row_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `row` location in the current table."
          },
          "column_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `column` location in the current table."
          },
          "column_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `column` location in the current table."
          }
        }
      },
      "TableRowHeaders": {
        "type": "object",
        "description": "Row-level cells, each applicable as a header to other cells in the same row as itself, of the current table.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the cell in the current table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The textual contents of this cell from the input document without associated markup content."
          },
          "text_normalized": {
            "type": "string",
            "description": "Normalized row header text."
          },
          "row_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `row` location in the current table."
          },
          "row_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `row` location in the current table."
          },
          "column_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `column` location in the current table."
          },
          "column_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `column` location in the current table."
          }
        }
      },
      "TableKeyValuePairs": {
        "type": "object",
        "description": "Key-value pairs detected across cell boundaries.",
        "properties": {
          "key": {
            "$ref": "#/components/schemas/TableCellKey"
          },
          "value": {
            "$ref": "#/components/schemas/TableCellValue"
          }
        }
      },
      "TableCellKey": {
        "type": "object",
        "description": "A key in a key-value pair.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the key in the table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The text content of the table cell without HTML markup."
          }
        }
      },
      "TableCellValue": {
        "type": "array",
        "description": "A list of values in a key-value pair.",
        "items": {
          "$ref": "#/components/schemas/TableCellValues"
        }
      },
      "TableCellValues": {
        "type": "object",
        "description": "A value in a key-value pair.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the value in the table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The text content of the table cell without HTML markup."
          }
        }
      },
      "TableBodyCells": {
        "type": "object",
        "description": "Cells that are not table header, column header, or row header cells",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the cell in the current table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The textual contents of this cell from the input document without associated markup content."
          },
          "row_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `row` location in the current table."
          },
          "row_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `row` location in the current table."
          },
          "column_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `column` location in the current table."
          },
          "column_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `column` location in the current table."
          },
          "row_header_ids": {
            "description": "A list of ID values that represent the table row headers that are associated with this body cell.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "row_header_texts": {
            "description": "A list of row header values that are associated with this body cell.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "row_header_texts_normalized": {
            "description": "A list of normalized row header values that are associated with this body cell.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "column_header_ids": {
            "description": "A list of ID values that represent the column headers that are associated with this body cell.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "column_header_texts": {
            "description": "A list of column header values that are associated with this body cell.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "column_header_texts_normalized": {
            "description": "A list of normalized column header values that are associated with this body cell.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "attributes": {
            "description": "A list of document attributes",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentAttribute"
            }
          }
        }
      },
      "DocumentAttribute": {
        "type": "object",
        "description": "List of document attributes",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of attribute."
          },
          "text": {
            "type": "string",
            "description": "The text associated with the attribute."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          }
        }
      },
      "TableColumnHeaders": {
        "type": "object",
        "description": "Column-level cells, each applicable as a header to other cells in the same column as itself, of the current table.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the cell in the current table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The textual contents of this cell from the input document without associated markup content."
          },
          "text_normalized": {
            "type": "string",
            "description": "Normalized column header text."
          },
          "row_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `row` location in the current table."
          },
          "row_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `row` location in the current table."
          },
          "column_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `column` location in the current table."
          },
          "column_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `column` location in the current table."
          }
        }
      },
      "TableResultTable": {
        "type": "object",
        "description": "Full table object retrieved from Table Understanding Enrichment.",
        "properties": {
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The textual contents of the current table from the input document without associated markup content."
          },
          "section_title": {
            "$ref": "#/components/schemas/TableTextLocation"
          },
          "title": {
            "$ref": "#/components/schemas/TableTextLocation"
          },
          "table_headers": {
            "type": "array",
            "description": "An array of table-level cells that apply as headers to all the other cells in the current table.",
            "items": {
              "$ref": "#/components/schemas/TableHeaders"
            }
          },
          "row_headers": {
            "type": "array",
            "description": "An array of row-level cells, each applicable as a header to other cells in the same row as itself, of the current table.",
            "items": {
              "$ref": "#/components/schemas/TableRowHeaders"
            }
          },
          "column_headers": {
            "type": "array",
            "description": "An array of column-level cells, each applicable as a header to other cells in the same column as itself, of the current table.",
            "items": {
              "$ref": "#/components/schemas/TableColumnHeaders"
            }
          },
          "key_value_pairs": {
            "type": "array",
            "description": "An array of key-value pairs identified in the current table.",
            "items": {
              "$ref": "#/components/schemas/TableKeyValuePairs"
            }
          },
          "body_cells": {
            "type": "array",
            "description": "An array of cells that are neither table header nor column header nor row header cells, of the current table with corresponding row and column header associations.",
            "items": {
              "$ref": "#/components/schemas/TableBodyCells"
            }
          },
          "contexts": {
            "type": "array",
            "description": "An array of lists of textual entries across the document related to the current table being parsed.",
            "items": {
              "$ref": "#/components/schemas/TableTextLocation"
            }
          }
        }
      },
      "TableTextLocation": {
        "type": "object",
        "description": "Text and associated location within a table.",
        "properties": {
          "text": {
            "type": "string",
            "description": "The text retrieved."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          }
        }
      },
      "ErrorResponse": {
        "type": "object",
        "description": "Error response information",
        "required": [
          "code",
          "error"
        ],
        "properties": {
          "code": {
            "description": "The HTTP error status code.",
            "type": "integer",
            "format": "int32",
            "minimum": 100,
            "maximum": 600
          },
          "error": {
            "description": "A message describing the error.",
            "type": "string"
          }
        }
      },
      "QueryLarge": {
        "type": "object",
        "description": "Object that describes a long query.",
        "properties": {
          "collection_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A comma-separated list of collection IDs to be queried against."
          },
          "filter": {
            "type": "string",
            "description": "Searches for documents that match the Discovery Query Language criteria that is specified as input. Filter calls are cached and are faster than query calls because the results are not ordered by relevance. When used with the **aggregation**, **query**, or **natural_language_query** parameters, the **filter** parameter runs first. This parameter is useful for limiting results to those that contain specific metadata values."
          },
          "query": {
            "type": "string",
            "description": "A query search that is written in the Discovery Query Language and returns all matching documents in your data set with full enrichments and full text, and with the most relevant documents listed first. Use a query search when you want to find the most relevant search results. You can use this parameter or the **natural_language_query** parameter to specify the query input, but not both."
          },
          "natural_language_query": {
            "type": "string",
            "description": "A natural language query that returns relevant documents by using training data and natural language understanding. You can use this parameter or the **query** parameter to specify the query input, but not both. To filter the results based on criteria you specify, include the **filter** parameter in the request.",
            "minLength": 1,
            "maxLength": 2048
          },
          "aggregation": {
            "type": "string",
            "description": "An aggregation search that returns an exact answer by combining query search with filters. Useful for applications to build lists, tables, and time series. For more information about the supported types of aggregations, see the [Discovery documentation](/docs/discovery-data?topic=discovery-data-query-aggregations)."
          },
          "count": {
            "type": "integer",
            "description": "Number of results to return."
          },
          "return": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of the fields in the document hierarchy to return. You can specify both root-level (`text`) and nested (`extracted_metadata.filename`) fields. If this parameter is an empty list, then all fields are returned.",
            "x-item-name": "return_field"
          },
          "offset": {
            "type": "integer",
            "description": "The number of query results to skip at the beginning. For example, if the total number of results that are returned is 10 and the offset is 8, it returns the last two results."
          },
          "sort": {
            "type": "string",
            "description": "A comma-separated list of fields in the document to sort on. You can optionally specify a sort direction by prefixing the field with `-` for descending or `+` for ascending. Ascending is the default sort direction if no prefix is specified."
          },
          "highlight": {
            "type": "boolean",
            "description": "When `true`, a highlight field is returned for each result that contains fields that match the query. The matching query terms are emphasized with surrounding `<em></em>` tags. This parameter is ignored if **passages.enabled** and **passages.per_document** are `true`, in which case passages are returned for each document instead of highlights."
          },
          "spelling_suggestions": {
            "type": "boolean",
            "description": "When `true` and the **natural_language_query** parameter is used, the **natural_language_query** parameter is spell checked. The most likely correction is returned in the **suggested_query** field of the response (if one exists)."
          },
          "table_results": {
            "type": "object",
            "description": "Configuration for table retrieval",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Whether to enable table retrieval."
              },
              "count": {
                "type": "integer",
                "description": "Maximum number of tables to return."
              }
            }
          },
          "suggested_refinements": {
            "type": "object",
            "description": "Configuration for suggested refinements.\n\n**Note**: The **suggested_refinements** parameter that identified dynamic facets from the data is deprecated.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Whether to perform suggested refinements."
              },
              "count": {
                "type": "integer",
                "description": "Maximum number of suggested refinements texts to be returned. The maximum is `100`.",
                "maximum": 100,
                "minimum": 1
              }
            },
            "deprecated": true
          },
          "passages": {
            "type": "object",
            "description": "Configuration for passage retrieval.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "A passages query that returns the most relevant passages from the results."
              },
              "per_document": {
                "type": "boolean",
                "description": "If `true`, ranks the documents by document quality, and then returns the highest-ranked passages per document in a `document_passages` field for each document entry in the results list of the response.\n\nIf `false`, ranks the passages from all of the documents by passage quality regardless of the document quality and returns them in a separate `passages` field in the response."
              },
              "max_per_document": {
                "type": "integer",
                "description": "Maximum number of passages to return per document in the result. Ignored if **passages.per_document** is `false`."
              },
              "fields": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "A list of fields to extract passages from. By default, passages are extracted from the `text` and `title` fields only. If you add this parameter and specify an empty list (`[]`) as its value, then the service searches all root-level fields for suitable passages."
              },
              "count": {
                "type": "integer",
                "description": "The maximum number of passages to return. Ignored if **passages.per_document** is `true`.",
                "maximum": 400
              },
              "characters": {
                "type": "integer",
                "description": "The approximate number of characters that any one passage will have.",
                "maximum": 2000,
                "minimum": 50
              },
              "find_answers": {
                "type": "boolean",
                "description": "When true, `answer` objects are returned as part of each passage in the query results. The primary difference between an `answer` and a `passage` is that the length of a passage is defined by the query, where the length of an `answer` is calculated by Discovery based on how much text is needed to answer the question.\n\nThis parameter is ignored if passages are not enabled for the query, or no **natural_language_query** is specified.\n\nIf the **find_answers** parameter is set to `true` and **per_document** parameter is also set to `true`, then the document search results and the passage search results within each document are reordered using the answer confidences. The goal of this reordering is to place the best answer as the first answer of the first passage of the first document. Similarly, if the **find_answers** parameter is set to `true` and **per_document** parameter is set to `false`, then the passage search results are reordered in decreasing order of the highest confidence answer for each document and passage.\n\nThe **find_answers** parameter is available only on managed instances of Discovery.",
                "default": false
              },
              "max_answers_per_passage": {
                "type": "integer",
                "description": "The number of `answer` objects to return per passage if the **find_answers** parmeter is specified as `true`.",
                "default": 1
              }
            }
          },
          "similar": {
            "type": "object",
            "description": "Finds results from documents that are similar to documents of interest. Use this parameter to add a *More like these* function to your search. You can include this parameter with or without a **query**, **filter** or **natural_language_query** parameter.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, includes documents in the query results that are similar to documents you specify.",
                "default": false
              },
              "document_ids": {
                "type": "array",
                "description": "The list of documents of interest. Required if **enabled** is `true`.",
                "items": {
                  "type": "string"
                }
              },
              "fields": {
                "type": "array",
                "description": "Looks for similarities in the specified subset of fields in the documents. If not specified, all of the document fields are used.",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "RetrievalDetails": {
        "type": "object",
        "description": "An object contain retrieval type information.",
        "properties": {
          "document_retrieval_strategy": {
            "type": "string",
            "description": "Identifies the document retrieval strategy used for this query. `relevancy_training` indicates that the results were returned using a relevancy trained model. \n\n**Note**: In the event of trained collections being queried, but the trained model is not used to return results, the **document_retrieval_strategy** is listed as `untrained`.",
            "enum": [
              "untrained",
              "relevancy_training"
            ]
          }
        }
      },
      "Collection": {
        "type": "object",
        "description": "A collection for storing documents.",
        "properties": {
          "collection_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier of the collection."
          },
          "name": {
            "type": "string",
            "minLength": 0,
            "maxLength": 255,
            "description": "The name of the collection."
          }
        },
        "example": {
          "collection_id": "800e58e4-198d-45eb-be87-74e1d6df4e96",
          "name": "test-collection"
        }
      },
      "Completions": {
        "type": "object",
        "description": "An object that contains an array of autocompletion suggestions.",
        "properties": {
          "completions": {
            "type": "array",
            "description": "Array of autocomplete suggestion based on the provided prefix.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ComponentSettingsResponse": {
        "type": "object",
        "description": "The default component settings for this project.",
        "properties": {
          "fields_shown": {
            "$ref": "#/components/schemas/ComponentSettingsFieldsShown"
          },
          "autocomplete": {
            "type": "boolean",
            "description": "Whether or not autocomplete is enabled."
          },
          "structured_search": {
            "type": "boolean",
            "description": "Whether or not structured search is enabled."
          },
          "results_per_page": {
            "type": "integer",
            "format": "int32",
            "description": "Number or results shown per page."
          },
          "aggregations": {
            "type": "array",
            "description": "a list of component setting aggregations",
            "items": {
              "$ref": "#/components/schemas/ComponentSettingsAggregation"
            }
          }
        }
      },
      "ComponentSettingsFieldsShown": {
        "type": "object",
        "description": "Fields shown in the results section of the UI",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/ComponentSettingsFieldsShownBody"
          },
          "title": {
            "$ref": "#/components/schemas/ComponentSettingsFieldsShownTitle"
          }
        }
      },
      "ComponentSettingsFieldsShownTitle": {
        "type": "object",
        "description": "Title label",
        "properties": {
          "field": {
            "type": "string",
            "description": "Use a specific field as the title."
          }
        }
      },
      "ComponentSettingsFieldsShownBody": {
        "type": "object",
        "description": "Body label",
        "properties": {
          "use_passage": {
            "type": "boolean",
            "description": "Use the whole passage as the body."
          },
          "field": {
            "type": "string",
            "description": "Use a specific field as the title."
          }
        }
      },
      "ComponentSettingsAggregation": {
        "type": "object",
        "description": "Display settings for aggregations",
        "properties": {
          "name": {
            "type": "string",
            "description": "Identifier used to map aggregation settings to aggregation configuration."
          },
          "label": {
            "type": "string",
            "description": "User-friendly alias for the aggregation"
          },
          "multiple_selections_allowed": {
            "type": "boolean",
            "description": "Whether users is allowed to select more than one of the aggregation terms."
          },
          "visualization_type": {
            "type": "string",
            "enum": [
              "auto",
              "facet_table",
              "word_cloud",
              "map"
            ],
            "description": "Type of visualization to use when rendering the aggregation."
          }
        }
      },
      "DocumentAccepted": {
        "description": "Information returned after an uploaded document is accepted.",
        "type": "object",
        "properties": {
          "document_id": {
            "type": "string",
            "description": "The unique identifier of the ingested document."
          },
          "status": {
            "type": "string",
            "enum": [
              "processing",
              "pending"
            ],
            "description": "Status of the document in the ingestion process. A status of `processing` is returned for documents that are ingested with a *version* date before `2019-01-01`. The `pending` status is returned for all others."
          }
        },
        "example": {
          "document_id": "f1360220-ea2d-4271-9d62-89a910b13c37",
          "status": "processing"
        }
      },
      "DeleteDocumentResponse": {
        "description": "Information returned when a document is deleted.",
        "type": "object",
        "properties": {
          "document_id": {
            "type": "string",
            "description": "The unique identifier of the document."
          },
          "status": {
            "type": "string",
            "enum": [
              "deleted"
            ],
            "description": "Status of the document. A deleted document has the status deleted."
          }
        }
      },
      "TrainingQuery": {
        "type": "object",
        "description": "Object that contains training query details.",
        "required": [
          "natural_language_query",
          "examples"
        ],
        "properties": {
          "query_id": {
            "description": "The query ID associated with the training query.",
            "type": "string",
            "readOnly": true
          },
          "natural_language_query": {
            "description": "The natural text query that is used as the training query.",
            "type": "string"
          },
          "filter": {
            "description": "The filter used on the collection before the **natural_language_query** is applied. Only specify a filter if the documents that you consider to be most relevant are not included in the top 100 results when you submit test queries. If you specify a filter during training, apply the same filter to queries that are submitted at runtime for optimal ranking results.",
            "type": "string"
          },
          "created": {
            "description": "The date and time the query was created.",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "updated": {
            "description": "The date and time the query was updated.",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "examples": {
            "description": "Array of training examples.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingExample"
            }
          }
        }
      },
      "TrainingExample": {
        "type": "object",
        "description": "Object that contains example response details for a training query.",
        "required": [
          "document_id",
          "collection_id",
          "relevance"
        ],
        "properties": {
          "document_id": {
            "description": "The document ID associated with this training example.",
            "type": "string"
          },
          "collection_id": {
            "description": "The collection ID associated with this training example.",
            "type": "string"
          },
          "relevance": {
            "description": "The relevance score of the training example. Scores range from `0` to `100`. Zero means not relevant. The higher the number, the more relevant the example.",
            "type": "integer",
            "format": "int32"
          },
          "created": {
            "description": "The date and time the example was created.",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "updated": {
            "description": "The date and time the example was updated.",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "TrainingQuerySet": {
        "type": "object",
        "description": "Object specifying the training queries contained in the identified training set.",
        "properties": {
          "queries": {
            "description": "Array of training queries. At least 50 queries are required for training to begin. A maximum of 10,000 queries are returned.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingQuery"
            },
            "minItems": 50,
            "maxItems": 10000
          }
        }
      },
      "ListFieldsResponse": {
        "type": "object",
        "description": "The list of fetched fields.\n\nThe fields are returned using a fully qualified name format, however, the format differs slightly from that used by the query operations.\n\n  * Fields which contain nested objects are assigned a type of \"nested\".\n\n  * Fields which belong to a nested object are prefixed with `.properties` (for example, `warnings.properties.severity` means that the `warnings` object has a property called `severity`).",
        "properties": {
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Field"
            },
            "description": "An array that contains information about each field in the collections."
          }
        }
      },
      "Field": {
        "description": "Object that contains field details.",
        "type": "object",
        "properties": {
          "field": {
            "type": "string",
            "readOnly": true,
            "description": "The name of the field."
          },
          "type": {
            "type": "string",
            "enum": [
              "nested",
              "string",
              "date",
              "long",
              "integer",
              "short",
              "byte",
              "double",
              "float",
              "boolean",
              "binary"
            ],
            "readOnly": true,
            "description": "The type of the field."
          },
          "collection_id": {
            "type": "string",
            "readOnly": true,
            "description": "The collection Id of the collection where the field was found."
          }
        }
      },
      "QueryNoticesResponse": {
        "description": "Object that contains notice query results.",
        "type": "object",
        "properties": {
          "matching_results": {
            "description": "The number of matching results",
            "type": "integer",
            "format": "int32"
          },
          "notices": {
            "description": "Array of document results that match the query.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Notice"
            }
          }
        }
      },
      "Notice": {
        "type": "object",
        "description": "A notice produced for the collection.",
        "properties": {
          "notice_id": {
            "type": "string",
            "readOnly": true,
            "description": "Identifies the notice. Many notices might have the same ID. This field exists so that user applications can programmatically identify a notice and take automatic corrective action. Typical notice IDs include:\n\n`index_failed`, `index_failed_too_many_requests`, `index_failed_incompatible_field`, `index_failed_cluster_unavailable`, `ingestion_timeout`, `ingestion_error`, `bad_request`, `internal_error`, `missing_model`, `unsupported_model`, `smart_document_understanding_failed_incompatible_field`, `smart_document_understanding_failed_internal_error`, `smart_document_understanding_failed_internal_error`, `smart_document_understanding_failed_warning`, `smart_document_understanding_page_error`, `smart_document_understanding_page_warning`. **Note:** This is not a complete list. Other values might be returned."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The creation date of the collection in the format yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
          },
          "document_id": {
            "type": "string",
            "readOnly": true,
            "description": "Unique identifier of the document."
          },
          "collection_id": {
            "type": "string",
            "readOnly": true,
            "description": "Unique identifier of the collection."
          },
          "query_id": {
            "type": "string",
            "readOnly": true,
            "description": "Unique identifier of the query used for relevance training."
          },
          "severity": {
            "type": "string",
            "enum": [
              "warning",
              "error"
            ],
            "readOnly": true,
            "description": "Severity level of the notice."
          },
          "step": {
            "type": "string",
            "readOnly": true,
            "description": "Ingestion or training step in which the notice occurred."
          },
          "description": {
            "type": "string",
            "readOnly": true,
            "description": "The description of the notice."
          }
        }
      },
      "Curations": {
        "description": "Array of queries with curated responses for the specified project.",
        "type": "object",
        "properties": {
          "project_id": {
            "description": "The project ID of the project that contains these curations.",
            "type": "string"
          },
          "curations": {
            "description": "Array of curated queries and responses.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Curation"
            }
          }
        }
      },
      "Curation": {
        "description": "Curated query and responses.",
        "type": "object",
        "properties": {
          "curation_id": {
            "description": "The curation ID of this curation.",
            "type": "string",
            "readOnly": true
          },
          "natural_language_query": {
            "description": "The curated natural language query.",
            "type": "string"
          },
          "curated_results": {
            "description": "Array of curated results.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurationResult"
            }
          }
        }
      },
      "CuratedResults": {
        "description": "Object that contains an array of curated results.",
        "type": "object",
        "properties": {
          "curated_results": {
            "description": "Array of curated results.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurationResult"
            }
          }
        }
      },
      "CurationResult": {
        "description": "Result information for a curated query.",
        "type": "object",
        "properties": {
          "document_id": {
            "description": "The document ID of the curated result.",
            "type": "string"
          },
          "collection_id": {
            "description": "The collection ID of the curated result.",
            "type": "string"
          },
          "snippet": {
            "type": "string",
            "minLength": 0,
            "maxLength": 2000,
            "description": "Text to return in the `passage_text` field when this curated document is returned for the specified natural language query. If **passages.per_document** is `true`, the text snippet that you specify is returned as the top passage instead of the original passage that is chosen by search. Only one text snippet can be specified per document. If **passages.max_per_document** is greater than `1`, the snippet is returned first, followed by the passages that are chosen by search."
          }
        }
      },
      "CurationStatus": {
        "description": "Curation status information.",
        "type": "object",
        "properties": {
          "curation_id": {
            "description": "The curation ID of the curation.",
            "type": "string"
          },
          "status": {
            "description": "The current status of the specified curation.",
            "type": "string"
          }
        }
      },
      "CollectionDetails": {
        "type": "object",
        "description": "A collection for storing documents.",
        "required": [
          "name"
        ],
        "properties": {
          "collection_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier of the collection."
          },
          "name": {
            "type": "string",
            "minLength": 0,
            "maxLength": 255,
            "description": "The name of the collection."
          },
          "description": {
            "type": "string",
            "description": "A description of the collection."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the collection was created."
          },
          "language": {
            "type": "string",
            "description": "The language of the collection. For a list of supported languages, see the [product documentation](/docs/discovery-data?topic=discovery-data-language-support).",
            "default": "en"
          },
          "enrichments": {
            "type": "array",
            "description": "An array of enrichments that are applied to this collection. To get a list of enrichments that are available for a project, use the [List enrichments](#listenrichments) method.\n\nIf no enrichments are specified when the collection is created, the default enrichments for the project type are applied. For more information about project default settings, see the [product documentation](/docs/discovery-data?topic=discovery-data-project-defaults).",
            "items": {
              "$ref": "#/components/schemas/CollectionEnrichment"
            }
          },
          "webhooks": {
            "$ref": "#/components/schemas/Webhooks"
          },
          "conversions": {
            "$ref": "#/components/schemas/Conversions"
          },
          "normalizations": {
            "$ref": "#/components/schemas/Normalizations"
          },
          "smart_document_understanding": {
            "type": "object",
            "readOnly": true,
            "description": "An object that describes the Smart Document Understanding model for a collection.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, smart document understanding conversion is enabled for the collection."
              },
              "model": {
                "type": "string",
                "description": "Specifies the type of Smart Document Understanding (SDU) model that is enabled for the collection. The following types of models are supported:\n\n * `custom`: A user-trained model is applied.\n\n * `pre_trained`: A pretrained model is applied. This type of model is applied automatically to *Document Retrieval for Contracts* projects.\n\n * `text_extraction`: An SDU model that extracts text and metadata from the content. This model is enabled in collections by default regardless of the types of documents in the collection (as long as the service plan supports SDU models).\n\nYou can apply user-trained or pretrained models to collections from the *Identify fields* page of the product user interface. For more information, see [the product documentation](/docs/discovery-data?topic=discovery-data-configuring-fields).",
                "enum": [
                  "custom",
                  "pre_trained",
                  "text_extraction"
                ]
              }
            }
          },
          "source_document_counts": {
            "type": "object",
            "readOnly": true,
            "description": "Object that describes the status of documents that are uploaded to a collection or that are added from a crawled external data source. To get the total number of documents, sum the values of the status types.\n\nDocument status information is returned asynchronously. If counts are zero, wait a minute and then use the *Get collection details* method to check the status.\n\n**Note**: Available from installed instances starting with Cloud Pak for Data 4.7 and from IBM Cloud-managed instances only.",
            "properties": {
              "pending": {
                "description": "Number of source documents that are uploaded to the collection, but not converted yet.",
                "type": "integer",
                "format": "int32"
              },
              "processing": {
                "description": "Number of source documents in the collection that are being processed.",
                "type": "integer",
                "format": "int32"
              },
              "available": {
                "description": "Number of source documents in the collection that were added successfully. The number includes any original parent documents that are split into subdocuments during the ingestion process, but does not include the resulting subdocuments in the count.",
                "type": "integer",
                "format": "int32"
              },
              "failed": {
                "description": "Number of source documents in the collection for which processing failed. If the original document is split and some subdocuments from it are added successfully but other subdocuments aren't, the status of the original document shows as failed.",
                "type": "integer",
                "format": "int32"
              }
            },
            "x-sdk-exclude": true
          },
          "document_counts": {
            "type": "object",
            "readOnly": true,
            "description": "Object with counts of documents in the collection grouped by document status.\n\nDocument status information is returned asynchronously. If counts are zero, wait a minute and then use the *Get collection details* method to check the status.\n\n**Note**: Available from installed instances starting with Cloud Pak for Data 4.7 and from IBM Cloud-managed instances only.",
            "properties": {
              "processing": {
                "description": "Number of documents that are either waiting to be or are being enriched and are not yet available in the collection to be queried.",
                "type": "integer",
                "format": "int32"
              },
              "available": {
                "description": "Number of documents in the collection that were processed successfully and are available to be queried. The number includes any subdocuments that are generated when a source document is split during the ingestion process, but does not include the original parent document.",
                "type": "integer",
                "format": "int32"
              },
              "failed": {
                "description": "Number of documents in the collection for which processing failed.",
                "type": "integer",
                "format": "int32"
              }
            },
            "x-sdk-exclude": true
          }
        }
      },
      "DocumentDetails": {
        "type": "object",
        "description": "Information about a document.",
        "required": [
          "document_id"
        ],
        "properties": {
          "document_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier of the document."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "Date and time that the document is added to the collection. For a child document, the date and time when the process that generates the child document runs. The date-time format is `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`."
          },
          "updated": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "Date and time that the document is finished being processed and is indexed. This date changes whenever the document is reprocessed, including for enrichment changes. The date-time format is `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`."
          },
          "status": {
            "type": "string",
            "description": "The status of the ingestion of the document. The possible values are:\n\n* `available`: Ingestion is finished and the document is indexed.\n\n* `failed`: Ingestion is finished, but the document is not indexed because of an error.\n\n* `pending`: The document is uploaded, but the ingestion process is not started.\n\n* `processing`: Ingestion is in progress.",
            "enum": [
              "available",
              "failed",
              "pending",
              "processing"
            ]
          },
          "notices": {
            "description": "Array of JSON objects for notices, meaning warning or error messages, that are produced by the document ingestion process. The array does not include notices that are produced for child documents that are generated when a document is processed.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Notice"
            }
          },
          "children": {
            "type": "object",
            "description": "Information about the child documents that are generated from a single document during ingestion or other processing.",
            "properties": {
              "have_notices": {
                "type": "boolean",
                "description": "Indicates whether the child documents have any notices. The value is `false` if the document does not have child documents."
              },
              "count": {
                "type": "integer",
                "description": "Number of child documents. The value is `0` when processing of the document doesn't generate any child documents."
              }
            }
          },
          "filename": {
            "type": "string",
            "description": "Name of the original source file (if available)."
          },
          "file_type": {
            "type": "string",
            "description": "The type of the original source file, such as `csv`, `excel`, `html`, `json`, `pdf`, `text`, `word`, and so on."
          },
          "sha256": {
            "type": "string",
            "description": "The SHA-256 hash of the original source file. The hash is formatted as a hexadecimal string."
          }
        }
      },
      "CollectionEnrichment": {
        "type": "object",
        "description": "An object describing an enrichment for a collection",
        "properties": {
          "enrichment_id": {
            "type": "string",
            "description": "The unique identifier of this enrichment. For more information about how to determine the ID of an enrichment, see [the product documentation](/docs/discovery-data?topic=discovery-data-manage-enrichments#enrichments-ids)."
          },
          "fields": {
            "type": "array",
            "description": "An array of field names that the enrichment is applied to.\n\nIf you apply an enrichment to a field from a JSON file, the data is converted to an array automatically, even if the field contains a single value.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Webhooks": {
        "type": "object",
        "description": "An object with webhook information. For more information, see [Document status webhook API](/docs/discovery-data?topic=discovery-data-document-status-api). \n\n**Note**:The document status webhook API is beta functionality. This feature is available from IBM Cloud-managed instances only.",
        "properties": {
          "document_status": {
            "$ref": "#/components/schemas/DocumentStatus"
          }
        },
        "x-sdk-exclude": true
      },
      "ListProjectsResponse": {
        "type": "object",
        "description": "A list of projects in this instance.",
        "properties": {
          "projects": {
            "type": "array",
            "description": "An array of project details.",
            "items": {
              "$ref": "#/components/schemas/ProjectListDetails"
            }
          }
        }
      },
      "ProjectListDetails": {
        "type": "object",
        "description": "Details about a specific project.",
        "properties": {
          "project_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier of this project."
          },
          "name": {
            "type": "string",
            "description": "The human readable name of this project."
          },
          "type": {
            "type": "string",
            "description": "The type of project.\n\nThe `content_intelligence` type is a *Document Retrieval for Contracts* project and the `other` type is a *Custom* project.\n\nThe `content_mining` and `content_intelligence` types are available with Premium plan managed deployments and installed deployments only.\n\nThe Intelligent Document Processing (IDP) project type is available from IBM Cloud-managed instances only.",
            "enum": [
              "intelligent_document_processing",
              "document_retrieval",
              "conversational_search",
              "content_mining",
              "content_intelligence",
              "other"
            ]
          },
          "relevancy_training_status": {
            "type": "object",
            "readOnly": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/ProjectRelTrainStatus"
              }
            ]
          },
          "collection_count": {
            "type": "integer",
            "readOnly": true,
            "description": "The number of collections configured in this project."
          }
        }
      },
      "ProjectDetails": {
        "description": "Detailed information about the specified project.",
        "allOf": [
          {
            "$ref": "#/components/schemas/ProjectListDetails"
          },
          {
            "type": "object",
            "description": "Extended details about a specific project.",
            "properties": {
              "default_query_parameters": {
                "$ref": "#/components/schemas/DefaultQueryParams"
              }
            }
          }
        ]
      },
      "ProjectRelTrainStatus": {
        "type": "object",
        "readOnly": true,
        "description": "Relevancy training status information for this project.",
        "properties": {
          "data_updated": {
            "type": "string",
            "description": "When the training data was updated."
          },
          "total_examples": {
            "type": "integer",
            "description": "The total number of examples."
          },
          "sufficient_label_diversity": {
            "type": "boolean",
            "description": "When `true`, sufficient label diversity is present to allow training for this project."
          },
          "processing": {
            "type": "boolean",
            "description": "When `true`, the relevancy training is in processing."
          },
          "minimum_examples_added": {
            "type": "boolean",
            "description": "When `true`, the minimum number of examples required to train has been met."
          },
          "successfully_trained": {
            "type": "string",
            "description": "The time that the most recent successful training occurred"
          },
          "available": {
            "type": "boolean",
            "description": "When `true`, relevancy training is available when querying collections in the project."
          },
          "notices": {
            "type": "integer",
            "description": "The number of notices generated during the relevancy training."
          },
          "minimum_queries_added": {
            "type": "boolean",
            "description": "When `true`, the minimum number of queries required to train has been met."
          }
        }
      },
      "Enrichments": {
        "type": "object",
        "description": "An object that contains an array of enrichment definitions.",
        "properties": {
          "enrichments": {
            "type": "array",
            "description": "An array of enrichment definitions.",
            "items": {
              "$ref": "#/components/schemas/Enrichment"
            }
          }
        }
      },
      "Enrichment": {
        "type": "object",
        "description": "Information about a specific enrichment.",
        "properties": {
          "enrichment_id": {
            "readOnly": true,
            "type": "string",
            "description": "The unique identifier of this enrichment."
          },
          "name": {
            "type": "string",
            "description": "The human readable name for this enrichment."
          },
          "description": {
            "type": "string",
            "description": "The description of this enrichment."
          },
          "type": {
            "type": "string",
            "description": "The type of this enrichment.",
            "enum": [
              "part_of_speech",
              "sentiment",
              "natural_language_understanding",
              "dictionary",
              "regular_expression",
              "uima_annotator",
              "rule_based",
              "watson_knowledge_studio_model",
              "classifier",
              "webhook",
              "sentence_classifier"
            ]
          },
          "options": {
            "$ref": "#/components/schemas/EnrichmentOptions"
          }
        }
      },
      "EnrichmentOptions": {
        "type": "object",
        "description": "An object that contains options for the current enrichment. Starting with version `2020-08-30`, the enrichment options are not included in responses from the List Enrichments method.",
        "properties": {
          "languages": {
            "type": "array",
            "description": "An array of supported languages for this enrichment. When creating an enrichment, only specify a language that is used by the model or in the dictionary. Required when **type** is `dictionary`. Optional when **type** is `rule_based`. Not valid when creating any other type of enrichment.",
            "items": {
              "type": "string"
            }
          },
          "entity_type": {
            "type": "string",
            "description": "The name of the entity type. This value is used as the field name in the index. Required when **type** is `dictionary` or `regular_expression`. Not valid when creating any other type of enrichment."
          },
          "regular_expression": {
            "type": "string",
            "description": "The regular expression to apply for this enrichment. Required when **type** is `regular_expression`. Not valid when creating any other type of enrichment."
          },
          "result_field": {
            "type": "string",
            "description": "The name of the result document field that this enrichment creates. Required when **type** is `rule_based` or `classifier`. Not valid when creating any other type of enrichment."
          },
          "classifier_id": {
            "type": "string",
            "description": "A unique identifier of the document classifier. Required when **type** is `classifier`. Not valid when creating any other type of enrichment."
          },
          "model_id": {
            "type": "string",
            "description": "A unique identifier of the document classifier model. Required when **type** is `classifier`. Not valid when creating any other type of enrichment."
          },
          "confidence_threshold": {
            "type": "number",
            "description": "Specifies a threshold. Only classes with evaluation confidence scores that are higher than the specified threshold are included in the output. Optional when **type** is `classifier`. Not valid when creating any other type of enrichment.",
            "format": "double",
            "default": 0,
            "minimum": 0,
            "maximum": 1
          },
          "top_k": {
            "type": "integer",
            "default": 0,
            "description": "Evaluates only the classes that fall in the top set of results when ranked by confidence. For example, if set to `5`, then the top five classes for each document are evaluated. If set to 0, the **confidence_threshold** is used to determine the predicted classes. Optional when **type** is `classifier`. Not valid when creating any other type of enrichment."
          },
          "url": {
            "type": "string",
            "description": "A URL that uses the SSL protocol (begins with https) for the webhook. Required when type is `webhook`. Not valid when creating any other type of enrichment."
          },
          "version": {
            "type": "string",
            "default": "2023-03-31",
            "description": "The Discovery API version that allows to distinguish the schema. The version is specified in the `yyyy-mm-dd` format. Optional when `type` is `webhook`. Not valid when creating any other type of enrichment."
          },
          "secret": {
            "type": "string",
            "description": "A private key can be included in the request to authenticate with the external service. The maximum length is 1,024 characters. Optional when `type` is `webhook`. Not valid when creating any other type of enrichment."
          },
          "headers": {
            "$ref": "#/components/schemas/WebhookHeader"
          },
          "location_encoding": {
            "type": "string",
            "default": "`utf-16`",
            "description": "Discovery calculates offsets of the text's location with this encoding type in documents. Use the same location encoding type in both Discovery and external enrichment for a document.\n\n These encoding types are supported: `utf-8`, `utf-16`, and `utf-32`. Optional when `type` is `webhook`. Not valid when creating any other type of enrichment."
          }
        },
        "x-ibm-change-notices": [
          {
            "version": "2020-08-30",
            "type": "update",
            "description": "The enrichment options are not included in responses from the [List enrichments](#listenrichments) method. They continue to be returned with the [Get enrichment](#getenrichment) method."
          }
        ]
      },
      "UpdateEnrichment": {
        "type": "object",
        "description": "An object that contains a new name and description for an enrichment.",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A new name for the enrichment."
          },
          "description": {
            "type": "string",
            "description": "A new description for the enrichment."
          }
        }
      },
      "AnalyzedDocument": {
        "type": "object",
        "description": "An object that contains the converted document and any identified enrichments. Root-level fields from the original file are returned also.",
        "properties": {
          "notices": {
            "description": "Array of notices that are triggered when the files are processed.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Notice"
            }
          },
          "result": {
            "$ref": "#/components/schemas/AnalyzedResult"
          }
        }
      },
      "AnalyzedResult": {
        "type": "object",
        "description": "Result of the document analysis.",
        "properties": {
          "metadata": {
            "type": "object",
            "description": "Metadata that was specified with the request.",
            "additionalProperties": true
          }
        },
        "additionalProperties": {
          "type": "object",
          "description": "The remaining key-value pairs"
        }
      },
      "DefaultQueryParams": {
        "type": "object",
        "description": "Default query parameters for this project.",
        "properties": {
          "collection_ids": {
            "type": "array",
            "description": "An array of collection identifiers to query. If empty or omitted all collections in the project are queried.",
            "items": {
              "type": "string"
            }
          },
          "passages": {
            "type": "object",
            "description": "Default settings configuration for passage search options.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, a passage search is performed by default."
              },
              "count": {
                "type": "integer",
                "description": "The number of passages to return."
              },
              "fields": {
                "type": "array",
                "description": "An array of field names to perform the passage search on.",
                "items": {
                  "type": "string"
                }
              },
              "characters": {
                "type": "integer",
                "description": "The approximate number of characters that each returned passage will contain."
              },
              "per_document": {
                "type": "boolean",
                "description": "When `true` the number of passages that can be returned from a single document is restricted to the *max_per_document* value."
              },
              "max_per_document": {
                "type": "integer",
                "description": "The default maximum number of passages that can be taken from a single document as the result of a passage query."
              }
            }
          },
          "table_results": {
            "type": "object",
            "description": "Default project query settings for table results.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, a table results for the query are returned by default."
              },
              "count": {
                "type": "integer",
                "description": "The number of table results to return by default."
              },
              "per_document": {
                "type": "integer",
                "default": 0,
                "description": "The number of table results to include in each result document."
              }
            }
          },
          "aggregation": {
            "type": "string",
            "description": "A string representing the default aggregation query for the project."
          },
          "suggested_refinements": {
            "type": "object",
            "description": "Object that contains suggested refinement settings.\n\n**Note**: The `suggested_refinements` parameter that identified dynamic facets from the data is deprecated.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, suggested refinements for the query are returned by default."
              },
              "count": {
                "type": "integer",
                "description": "The number of suggested refinements to return by default."
              }
            },
            "deprecated": true
          },
          "spelling_suggestions": {
            "type": "boolean",
            "description": "When `true`, a spelling suggestions for the query are returned by default."
          },
          "highlight": {
            "type": "boolean",
            "description": "When `true`, highlights for the query are returned by default."
          },
          "count": {
            "type": "integer",
            "description": "The number of document results returned by default."
          },
          "sort": {
            "type": "string",
            "description": "A comma separated list of document fields to sort results by default."
          },
          "return": {
            "type": "array",
            "description": "An array of field names to return in document results if present by default.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ProjectName": {
        "type": "object",
        "description": "Object that contains a new name for the specified project.",
        "properties": {
          "name": {
            "type": "string",
            "description": "The new name to give this project."
          }
        }
      },
      "ProjectCreationDetails": {
        "type": "object",
        "description": "Details about a specific project.",
        "required": [
          "name",
          "type"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The human readable name of this project."
          },
          "type": {
            "type": "string",
            "description": "The type of project.\n\nThe `content_intelligence` type is a *Document Retrieval for Contracts* project and the `other` type is a *Custom* project.\n\nThe `content_mining` and `content_intelligence` types are available with Premium plan managed deployments and installed deployments only.\n\nThe Intelligent Document Processing (IDP) project type is available from IBM Cloud-managed instances only.",
            "enum": [
              "intelligent_document_processing",
              "document_retrieval",
              "conversational_search",
              "content_intelligence",
              "content_mining",
              "other"
            ]
          }
        }
      },
      "ProjectCreation": {
        "description": "Detailed information about the specified project.",
        "allOf": [
          {
            "$ref": "#/components/schemas/ProjectCreationDetails"
          },
          {
            "type": "object",
            "description": "Extended details about a specific project.",
            "properties": {
              "default_query_parameters": {
                "$ref": "#/components/schemas/DefaultQueryParams"
              }
            }
          }
        ]
      },
      "UpdateCollection": {
        "type": "object",
        "description": "An object that represents the collection to be updated.",
        "properties": {
          "name": {
            "type": "string",
            "minLength": 0,
            "maxLength": 255,
            "description": "The new name of the collection."
          },
          "description": {
            "type": "string",
            "description": "The new description of the collection."
          },
          "enrichments": {
            "type": "array",
            "description": "An array of enrichments that are applied to this collection.",
            "items": {
              "$ref": "#/components/schemas/CollectionEnrichment"
            }
          },
          "webhooks": {
            "$ref": "#/components/schemas/Webhooks"
          },
          "conversions": {
            "$ref": "#/components/schemas/Conversions"
          },
          "normalizations": {
            "$ref": "#/components/schemas/Normalizations"
          }
        }
      },
      "CreateEnrichment": {
        "type": "object",
        "description": "Information about a specific enrichment.",
        "properties": {
          "name": {
            "type": "string",
            "description": "The human readable name for this enrichment."
          },
          "description": {
            "type": "string",
            "description": "The description of this enrichment."
          },
          "type": {
            "type": "string",
            "description": "The type of this enrichment. The following types are supported:\n\n* `classifier`: Creates a document classifier enrichment from a document classifier model that you create by using the [Document classifier API](/apidocs/discovery-data#createdocumentclassifier). **Note**: A text classifier enrichment can be created only from the product user interface.\n\n* `dictionary`: Creates a custom dictionary enrichment that you define in a CSV file.\n\n* `regular_expression`: Creates a custom regular expression enrichment from regex syntax that you specify in the request.\n\n* `rule_based`: Creates an enrichment from an advanced rules model that is created and exported as a ZIP file from Watson Knowledge Studio.\n\n* `uima_annotator`: Creates an enrichment from a custom UIMA text analysis model that is defined in a PEAR file created in one of the following ways:\n\n    * Watson Explorer Content Analytics Studio. **Note**: Supported in IBM Cloud Pak for Data instances only.\n\n    * Rule-based model that is created in Watson Knowledge Studio.\n\n* `watson_knowledge_studio_model`: Creates an enrichment from a Watson Knowledge Studio machine learning model that is defined in a ZIP file.\n\n* `webhook`: Connects to an external enrichment application by using a webhook. The feature is available from IBM Cloud-managed instances only. The external enrichment feature is beta functionality. Beta features are not supported by the SDKs.\n\n* `sentence_classifier`: Use sentence classifier to classify sentences in your documents. This feature is available in IBM Cloud-managed instances only. The sentence classifier feature is beta functionality. Beta features are not supported by the SDKs.",
            "enum": [
              "classifier",
              "dictionary",
              "regular_expression",
              "uima_annotator",
              "rule_based",
              "watson_knowledge_studio_model",
              "webhook",
              "sentence_classifier"
            ]
          },
          "options": {
            "$ref": "#/components/schemas/EnrichmentOptions"
          }
        }
      },
      "ResultPassageAnswer": {
        "type": "object",
        "description": "Object that contains a potential answer to the specified query.",
        "properties": {
          "answer_text": {
            "type": "string",
            "description": "Answer text for the specified query as identified by Discovery."
          },
          "start_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position of the first character of the extracted answer in the originating field."
          },
          "end_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position after the last character of the extracted answer in the originating field."
          },
          "confidence": {
            "type": "number",
            "description": "An estimate of the probability that the answer is relevant.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "DocumentClassifiers": {
        "type": "object",
        "description": "An object that contains a list of document classifier definitions.",
        "properties": {
          "classifiers": {
            "type": "array",
            "description": "An array of document classifier definitions.",
            "items": {
              "$ref": "#/components/schemas/DocumentClassifier"
            }
          }
        }
      },
      "DocumentClassifier": {
        "type": "object",
        "description": "Information about a document classifier.",
        "required": [
          "classifier_id",
          "name"
        ],
        "properties": {
          "classifier_id": {
            "readOnly": true,
            "type": "string",
            "description": "A unique identifier of the document classifier."
          },
          "name": {
            "type": "string",
            "description": "A human-readable name of the document classifier.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A description of the document classifier."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the document classifier was created."
          },
          "language": {
            "type": "string",
            "description": "The language of the training data that is associated with the document classifier. Language is specified by using the ISO 639-1 language code, such as `en` for English or `ja` for Japanese.",
            "default": "en"
          },
          "enrichments": {
            "type": "array",
            "description": "An array of enrichments to apply to the data that is used to train and test the document classifier. The output from the enrichments is used as features by the classifier to classify the document content both during training and at run time.",
            "items": {
              "$ref": "#/components/schemas/DocumentClassifierEnrichment"
            }
          },
          "recognized_fields": {
            "type": "array",
            "description": "An array of fields that are used to train the document classifier. The same set of fields must exist in the training data, the test data, and the documents where the resulting document classifier enrichment is applied at run time.",
            "items": {
              "type": "string"
            }
          },
          "answer_field": {
            "type": "string",
            "description": "The name of the field from the training and test data that contains the classification labels."
          },
          "training_data_file": {
            "type": "string",
            "description": "Name of the CSV file with training data that is used to train the document classifier."
          },
          "test_data_file": {
            "type": "string",
            "description": "Name of the CSV file with data that is used to test the document classifier. If no test data is provided, a subset of the training data is used for testing purposes."
          },
          "federated_classification": {
            "$ref": "#/components/schemas/ClassifierFederatedModel"
          }
        }
      },
      "DocumentClassifierEnrichment": {
        "type": "object",
        "description": "An object that describes enrichments that are applied to the training and test data that is used by the document classifier.",
        "required": [
          "enrichment_id",
          "fields"
        ],
        "properties": {
          "enrichment_id": {
            "type": "string",
            "description": "A unique identifier of the enrichment."
          },
          "fields": {
            "type": "array",
            "description": "An array of field names where the enrichment is applied.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ClassifierFederatedModel": {
        "type": "object",
        "description": "An object with details for creating federated document classifier models.",
        "required": [
          "field"
        ],
        "properties": {
          "field": {
            "type": "string",
            "description": "Name of the field that contains the values from which multiple classifier models are defined. For example, you can specify a field that lists product lines to create a separate model per product line."
          }
        }
      },
      "CreateDocumentClassifier": {
        "type": "object",
        "description": "An object that manages the settings and data that is required to train a document classification model.",
        "required": [
          "name",
          "language",
          "answer_field"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A human-readable name of the document classifier.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A description of the document classifier."
          },
          "language": {
            "type": "string",
            "description": "The language of the training data that is associated with the document classifier. Language is specified by using the ISO 639-1 language code, such as `en` for English or `ja` for Japanese.",
            "default": "en"
          },
          "answer_field": {
            "type": "string",
            "description": "The name of the field from the training and test data that contains the classification labels."
          },
          "enrichments": {
            "type": "array",
            "description": "An array of enrichments to apply to the data that is used to train and test the document classifier. The output from the enrichments is used as features by the classifier to classify the document content both during training and at run time.",
            "items": {
              "$ref": "#/components/schemas/DocumentClassifierEnrichment"
            }
          },
          "federated_classification": {
            "$ref": "#/components/schemas/ClassifierFederatedModel"
          }
        }
      },
      "UpdateDocumentClassifier": {
        "type": "object",
        "description": "An object that contains a new name or description for a document classifier, updated training data, or new or updated test data.",
        "properties": {
          "name": {
            "type": "string",
            "description": "A new name for the classifier.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A new description for the classifier."
          }
        }
      },
      "DocumentClassifierModels": {
        "type": "object",
        "description": "An object that contains a list of document classifier model definitions.",
        "properties": {
          "models": {
            "type": "array",
            "description": "An array of document classifier model definitions.",
            "items": {
              "$ref": "#/components/schemas/DocumentClassifierModel"
            }
          }
        }
      },
      "DocumentClassifierModel": {
        "type": "object",
        "description": "Information about a document classifier model.",
        "required": [
          "model_id",
          "name"
        ],
        "properties": {
          "model_id": {
            "readOnly": true,
            "type": "string",
            "description": "A unique identifier of the document classifier model."
          },
          "name": {
            "type": "string",
            "description": "A human-readable name of the document classifier model.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A description of the document classifier model."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the document classifier model was created."
          },
          "updated": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the document classifier model was last updated."
          },
          "training_data_file": {
            "type": "string",
            "description": "Name of the CSV file that contains the training data that is used to train the document classifier model."
          },
          "test_data_file": {
            "type": "string",
            "description": "Name of the CSV file that contains data that is used to test the document classifier model. If no test data is provided, a subset of the training data is used for testing purposes."
          },
          "status": {
            "type": "string",
            "enum": [
              "training",
              "available",
              "failed"
            ],
            "description": "The status of the training run."
          },
          "evaluation": {
            "$ref": "#/components/schemas/ClassifierModelEvaluation"
          },
          "enrichment_id": {
            "type": "string",
            "description": "A unique identifier of the enrichment that is generated by this document classifier model."
          },
          "deployed_at": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the document classifier model was deployed."
          }
        }
      },
      "ClassifierModelEvaluation": {
        "type": "object",
        "description": "An object that contains information about a trained document classifier model.",
        "required": [
          "micro_average",
          "macro_average",
          "per_class"
        ],
        "properties": {
          "micro_average": {
            "$ref": "#/components/schemas/ModelEvaluationMicroAverage"
          },
          "macro_average": {
            "$ref": "#/components/schemas/ModelEvaluationMacroAverage"
          },
          "per_class": {
            "type": "array",
            "description": "An array of evaluation metrics, one set of metrics for each class, where class refers to the classification label that is specified in the **answer_field**.",
            "items": {
              "$ref": "#/components/schemas/PerClassModelEvaluation"
            }
          }
        }
      },
      "ModelEvaluationMacroAverage": {
        "type": "object",
        "description": "A macro-average computes metric independently for each class and then takes the average. Class refers to the classification label that is specified in the **answer_field**.",
        "required": [
          "precision",
          "recall",
          "f1"
        ],
        "properties": {
          "precision": {
            "type": "number",
            "description": "A metric that measures how many of the overall documents are classified correctly.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "recall": {
            "type": "number",
            "description": "A metric that measures how often documents that should be classified into certain classes are classified into those classes.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "f1": {
            "type": "number",
            "description": "A metric that measures whether the optimal balance between precision and recall is reached. The F1 score can be interpreted as a weighted average of the precision and recall values. An F1 score reaches its best value at 1 and worst value at 0.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "ModelEvaluationMicroAverage": {
        "type": "object",
        "required": [
          "precision",
          "recall",
          "f1"
        ],
        "description": "A micro-average aggregates the contributions of all classes to compute the average metric. Classes refers to the classification labels that are specified in the **answer_field**.",
        "properties": {
          "precision": {
            "type": "number",
            "description": "A metric that measures how many of the overall documents are classified correctly.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "recall": {
            "type": "number",
            "description": "A metric that measures how often documents that should be classified into certain classes are classified into those classes.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "f1": {
            "type": "number",
            "description": "A metric that measures whether the optimal balance between precision and recall is reached. The F1 score can be interpreted as a weighted average of the precision and recall values. An F1 score reaches its best value at 1 and worst value at 0.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "PerClassModelEvaluation": {
        "type": "object",
        "description": "An object that measures the metrics from a training run for each classification label separately.",
        "required": [
          "name",
          "precision",
          "recall",
          "f1"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Class name. Each class name is derived from a value in the **answer_field**."
          },
          "precision": {
            "type": "number",
            "description": "A metric that measures how many of the overall documents are classified correctly.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "recall": {
            "type": "number",
            "description": "A metric that measures how often documents that should be classified into certain classes are classified into those classes.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "f1": {
            "type": "number",
            "description": "A metric that measures whether the optimal balance between precision and recall is reached. The F1 score can be interpreted as a weighted average of the precision and recall values. An F1 score reaches its best value at 1 and worst value at 0.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "DocumentClassifierModelTrain": {
        "type": "object",
        "description": "An object that contains configuration settings for a document classifier model training run.",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 0,
            "maxLength": 255,
            "description": "The name of the document classifier model."
          },
          "description": {
            "type": "string",
            "description": "A description of the document classifier model."
          },
          "learning_rate": {
            "type": "number",
            "description": "A tuning parameter in an optimization algorithm that determines the step size at each iteration of the training process. It influences how much of any newly acquired information overrides the existing information, and therefore is said to represent the speed at which a machine learning model learns. The default value is `0.1`.",
            "format": "double",
            "default": 0.1,
            "minimum": 0,
            "maximum": 1
          },
          "l1_regularization_strengths": {
            "type": "array",
            "description": "Avoids overfitting by shrinking the coefficient of less important features to zero, which removes some features altogether. You can specify many values for hyper-parameter optimization. The default value is `[0.000001]`.",
            "items": {
              "type": "number",
              "format": "double",
              "minimum": 0
            },
            "default": [
              0.000001
            ]
          },
          "l2_regularization_strengths": {
            "type": "array",
            "description": "A method you can apply to avoid overfitting your model on the training data. You can specify many values for hyper-parameter optimization. The default value is `[0.000001]`.",
            "items": {
              "type": "number",
              "format": "double",
              "minimum": 0
            },
            "default": [
              0.000001
            ]
          },
          "training_max_steps": {
            "description": "Maximum number of training steps to complete. This setting is useful if you need the training process to finish in a specific time frame to fit into an automated process. The default value is ten million.",
            "type": "integer",
            "default": 10000000,
            "minimum": 0
          },
          "improvement_ratio": {
            "type": "number",
            "description": "Stops the training run early if the improvement ratio is not met by the time the process reaches a certain point. The default value is `0.00001`.",
            "format": "double",
            "default": 0.00001,
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "UpdateDocumentClassifierModel": {
        "type": "object",
        "description": "An object that contains a new name or description for a document classifier model.",
        "properties": {
          "name": {
            "type": "string",
            "description": "A new name for the enrichment.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A new description for the enrichment."
          }
        }
      },
      "StopWordList": {
        "type": "object",
        "required": [
          "stopwords"
        ],
        "description": "List of words to filter out of text that is submitted in queries.",
        "properties": {
          "stopwords": {
            "description": "List of stop words.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Expansions": {
        "type": "object",
        "required": [
          "expansions"
        ],
        "description": "The query expansion definitions for the specified collection.",
        "properties": {
          "expansions": {
            "type": "array",
            "description": "An array of query expansion definitions. \n\n Each object in the **expansions** array represents a term or set of terms that will be expanded into other terms. Each expansion object can be configured as `bidirectional` or `unidirectional`. \n\n* **Bidirectional**: Each entry in the `expanded_terms` list expands to include all expanded terms. For example, a query for `ibm` expands to `ibm OR international business machines OR big blue`.\n\n* **Unidirectional**: The terms in `input_terms` in the query are replaced by the terms in `expanded_terms`. For example, a query for the often misused term `on premise` is converted to `on premises OR on-premises` and does not contain the original term. If you want an input term to be included in the query, then repeat the input term in the expanded terms list.",
            "items": {
              "$ref": "#/components/schemas/Expansion"
            },
            "minItems": 0,
            "maxItems": 5000
          }
        }
      },
      "Expansion": {
        "type": "object",
        "required": [
          "expanded_terms"
        ],
        "description": "An expansion definition. Each object respresents one set of expandable strings. For example, you could have expansions for the word `hot` in one object, and expansions for the word `cold` in another. Follow these guidelines when you add terms:\n\n* Specify the terms in lowercase. Lowercase terms expand to uppercase.\n\n* Multiword terms are supported only in bidirectional expansions.\n\n* Do not specify a term that is specified in the stop words list for the collection.",
        "properties": {
          "input_terms": {
            "type": "array",
            "description": "A list of terms that will be expanded for this expansion. If specified, only the items in this list are expanded.",
            "items": {
              "type": "string"
            }
          },
          "expanded_terms": {
            "type": "array",
            "description": "A list of terms that this expansion will be expanded to. If specified without **input_terms**, the list also functions as the input term list.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Normalizations": {
        "description": "Defines operations that normalize the JSON representation of data after enrichments are applied. Operations run in the order that is specified in this array.\n\nNew fields that are added with a post-enrichment normalization are displayed in the JSON representation of query results, but are not available from product user interface pages, such as *Manage fields*.\n\n**Note**: Available only from service instances that are managed by IBM Cloud.",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/NormalizationOperation"
        },
        "x-item-name": "normalization",
        "x-sdk-exclude": true
      },
      "NormalizationOperation": {
        "description": "Object containing JSON normalization operations.",
        "type": "object",
        "properties": {
          "operation": {
            "description": "Identifies the type of operation to perform. The options include:\n\n- `copy`: Copies the value of the **source_field** to the **destination_field**. If the **destination_field** already exists, then its value is overwritten.\n\n- `move`: Moves the value of the **source_field** to the **destination_field**. If the **destination_field** already exists, then its value is overwritten. The `move` operation is the same as a `copy`, except that the **source_field** is removed after the value is copied.\n\n- `merge`: Merges the value of the **source_field** with the value of the **destination_field**, and then removes the **source_field**.\n\n  The **destination_field** is converted into an array and the value of the **source_field** is appended to the array. If the **destination_field** does not exist, the **source_field** remains unchanged and no **destination_field** is added.\n\n  - **conversions**: For JSON normalization operations that occur during ingestion, if the **source_field** does not exist in a document, the value in the **destination_field** is unchanged.\n\n  - **normalizations**: For JSON normalization operations that occur after enrichment, if the **source_field** does not exist in a document, the **destination_field** is converted to an array, even if the **destination_field** has a single value.\n\n  If you want to ensure that the data type of the **destination_field** is consistent across all documents, include both **normalizations** and **conversions** objects in the request.\n\n- `remove`: Deletes the field that is specified in the **source_field** parameter. The **destination_field** parameter is ignored for this operation.\n\n- `remove_nulls`: Removes all empty nested fields from the ingested document. (Empty root-level fields are removed by default.) The **source_field** and **destination_field** parameters are ignored by this operation because `remove_nulls` operates on the entire document. The `remove_nulls` operation often is called as the last normalization operation. However, it does increase the time it takes to process documents.",
            "type": "string",
            "enum": [
              "copy",
              "move",
              "merge",
              "remove",
              "remove_nulls"
            ]
          },
          "source_field": {
            "type": "string",
            "description": "The source field for the operation."
          },
          "destination_field": {
            "type": "string",
            "description": "The destination field for the operation. If the destination field is a new field, the name that you specify for it must meet the naming requirements that are listed in the [product documentation](https://cloud.ibm.com/docs/discovery-data?topic=discovery-data-index-overview#field-name-limits)."
          }
        }
      },
      "JsonNormalizations": {
        "description": "Defines operations that normalize the JSON representation of data at the end of the conversion phase of ingestion. When you specify a **source_field**, choose a field that will exist after data conversion. Operations run in the order that is specified in this array.\n\nNew root-level fields that are added with a conversion normalization are available from the product user interface, such as from the *Manage fields* page and the *Fields to enrich* lists in the *Enrichments* page.",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/NormalizationOperation"
        }
      },
      "Conversions": {
        "type": "object",
        "description": "Document processing operations that occur during the document conversion phase of ingestion.\n\n**Note**: Available only from service instances that are managed by IBM Cloud.",
        "properties": {
          "json_normalizations": {
            "$ref": "#/components/schemas/JsonNormalizations"
          }
        },
        "x-sdk-exclude": true
      },
      "ListBatchesResponse": {
        "description": "An object that contains a list of batches that are ready for enrichment by the external application.",
        "type": "object",
        "properties": {
          "batches": {
            "type": "array",
            "description": "An array that lists the batches in a collection.",
            "items": {
              "$ref": "#/components/schemas/BatchDetails"
            }
          }
        },
        "example": {
          "batches": [
            {
              "batch_id": "e9e1316b-a8b7-48d6-b538-e608af616a12",
              "enrichment_id": "fd290d8b-53e2-dba1-0000-018a8d150b85",
              "created": "2023-09-21T06:38:21.260Z"
            },
            {
              "batch_id": "aaab573d-e48c-3445-7b9d-5f3f9a9970215",
              "enrichment_id": "fd290d8b-53e2-dba1-0000-018a8d150b85",
              "created": "2023-09-21T05:38:21.260Z"
            }
          ]
        }
      },
      "pullBatchesResponse": {
        "description": "A compressed newline delimited JSON (NDJSON) file containing the document. The NDJSON format is used to describe structured data. The file name format is `{batch_id}.ndjson.gz`. For more information, see [Binary attachment from the pull batches method](/docs/discovery-data?topic=discovery-data-external-enrichment#binary-attachment-pull-batches).",
        "type": "object",
        "properties": {
          "file": {
            "type": "string",
            "description": "A compressed NDJSON file containing the document."
          }
        },
        "example": {
          "document_id": "3fb9f330-bd94-41a8-ac75-f732af13b5ac_1",
          "location_encoding": "utf-32",
          "language": "en",
          "artifact": "2016/1/2{\"parent_document_id\":\"3fb9f330-bd94-41a8-ac75-f732af13b5ac\"}1vanilla ice creamFemalecontamination_tamperingI got some ice cream for my children, but there was something like a piece of thread inside the cup.20QueensSilver Card MemberIce cream",
          "features": [
            {
              "type": "field",
              "location": {
                "begin": 0,
                "end": 8
              },
              "properties": {
                "field_name": "date",
                "field_index": 0,
                "field_type": "string"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 8,
                "end": 69
              },
              "properties": {
                "field_name": "metadata",
                "field_index": 0,
                "field_type": "json"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 69,
                "end": 70
              },
              "properties": {
                "field_name": "claim_id",
                "field_index": 0,
                "field_type": "long"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 70,
                "end": 87
              },
              "properties": {
                "field_name": "claim_product",
                "field_index": 0,
                "field_type": "string"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 87,
                "end": 93
              },
              "properties": {
                "field_name": "client_sex",
                "field_index": 0,
                "field_type": "string"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 93,
                "end": 116
              },
              "properties": {
                "field_name": "label",
                "field_index": 0,
                "field_type": "string"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 116,
                "end": 216
              },
              "properties": {
                "field_name": "body",
                "field_index": 0,
                "field_type": "string"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 216,
                "end": 218
              },
              "properties": {
                "field_name": "client_age",
                "field_index": 0,
                "field_type": "long"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 218,
                "end": 224
              },
              "properties": {
                "field_name": "client_location",
                "field_index": 0,
                "field_type": "string"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 224,
                "end": 242
              },
              "properties": {
                "field_name": "client_segment",
                "field_index": 0,
                "field_type": "string"
              }
            },
            {
              "type": "field",
              "location": {
                "begin": 242,
                "end": 251
              },
              "properties": {
                "field_name": "claim_product_line",
                "field_index": 0,
                "field_type": "string"
              }
            }
          ]
        }
      },
      "BatchDetails": {
        "type": "object",
        "description": "A batch is a set of documents that are ready for enrichment by an external application. After you apply a webhook enrichment to a collection, and then process or upload documents to the collection, Discovery creates a batch with a unique **batch_id**.",
        "properties": {
          "batch_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier for a batch of documents."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date and time (RFC3339) that the batch was created."
          },
          "enrichment_id": {
            "type": "string",
            "description": "The identifier for the external enrichment."
          }
        }
      },
      "BatchAccepted": {
        "description": "Whether or not a batch push of documents is successful. Discovery does not check what is included in the `.gz` file, and returns a response as soon as it temporarily stores a `.gz` file.\n\nDocuments included in a pushed `.gz` file are processed and annotations from the external enrichment are added to corresponding fields in the indexed documents of the collection.\n\nAny additional documents in the `.gz` file that were not in the batch (with the same **batch_id**) pulled from Discovery using the [Pull batches](#pullBatches) method are ignored.",
        "type": "boolean",
        "example": {
          "accepted": true
        }
      },
      "WebhookHeader": {
        "type": "object",
        "description": "An array of headers to pass with the HTTP request. Optional when `type` is `webhook`. Not valid when creating any other type of enrichment.",
        "required": [
          "name",
          "value"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of an HTTP header."
          },
          "value": {
            "type": "string",
            "description": "The value of an HTTP header."
          }
        }
      },
      "document_status": {
        "type": "array",
        "description": "Webhook service information to get the document details.",
        "items": {
          "$ref": "#/components/schemas/DocumentStatus"
        }
      },
      "DocumentStatus": {
        "type": "object",
        "description": "Webhook service information to get the document details.",
        "properties": {
          "url": {
            "type": "string",
            "description": "The webhook service endpoint."
          },
          "version": {
            "type": "string",
            "default": "2023-03-31",
            "description": " Discovery API version. The version is specified in the `yyyy-mm-dd` format. Webhook event payloads include the specified version. You can distinguish the payload schema version by it."
          },
          "secret": {
            "type": "string",
            "description": "A private key to pass with the request that can be used to authenticate with the external service."
          },
          "headers": {
            "description": "An array of HTTP headers to pass with the HTTP request. The headers in the array are the following:\n\n- `name`: (`string`) The name of an HTTP header. \n\n- `value`: (`string`) The value of an HTTP header."
          }
        }
      }
    }
  }
}